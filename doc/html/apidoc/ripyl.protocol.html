
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>protocol Package &mdash; Ripyl 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/ripyl.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Ripyl 1.0 documentation" href="../index.html" />
    <link rel="up" title="ripyl Package" href="ripyl.html" />
    <link rel="next" title="util Package" href="ripyl.util.html" />
    <link rel="prev" title="ripyl Package" href="ripyl.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ripyl.util.html" title="util Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="ripyl.html" title="ripyl Package"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Ripyl 1.0 documentation</a> &raquo;</li>
          <li><a href="modules.html" >ripyl</a> &raquo;</li>
          <li><a href="ripyl.html" accesskey="U">ripyl Package</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="protocol-package">
<h1>protocol Package<a class="headerlink" href="#protocol-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-ripyl.protocol.i2c">
<span id="i2c-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">i2c</span></tt> Module<a class="headerlink" href="#module-ripyl.protocol.i2c" title="Permalink to this headline">¶</a></h2>
<p>I2C protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.i2c.I2C">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.i2c.</tt><tt class="descname">I2C</tt><a class="headerlink" href="#ripyl.protocol.i2c.I2C" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for I2C r/w bit states</p>
<dl class="attribute">
<dt id="ripyl.protocol.i2c.I2C.Read">
<tt class="descname">Read</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.i2c.I2C.Read" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.i2c.I2C.Write">
<tt class="descname">Write</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.i2c.I2C.Write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.i2c.I2CAddress">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.i2c.</tt><tt class="descname">I2CAddress</tt><big>(</big><em>bounds</em>, <em>address=None</em>, <em>r_wn=None</em><big>)</big><a class="headerlink" href="#ripyl.protocol.i2c.I2CAddress" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></tt></a></p>
<p>Segment for an I2C address</p>
<p>The byte(s) composing the address are contained as subrecords</p>
<dl class="attribute">
<dt id="ripyl.protocol.i2c.I2CAddress.address">
<tt class="descname">address</tt><a class="headerlink" href="#ripyl.protocol.i2c.I2CAddress.address" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias of data attribute</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.i2c.I2CByte">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.i2c.</tt><tt class="descname">I2CByte</tt><big>(</big><em>bounds</em>, <em>data=None</em>, <em>ack_bit=None</em><big>)</big><a class="headerlink" href="#ripyl.protocol.i2c.I2CByte" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></tt></a></p>
<p>Segment for a byte of I2C data</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.i2c.I2CTransfer">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.i2c.</tt><tt class="descname">I2CTransfer</tt><big>(</big><em>r_wn</em>, <em>address</em>, <em>data</em><big>)</big><a class="headerlink" href="#ripyl.protocol.i2c.I2CTransfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></tt></a></p>
<p>Represent a transaction over the I2C bus</p>
<dl class="method">
<dt id="ripyl.protocol.i2c.I2CTransfer.ack_bits">
<tt class="descname">ack_bits</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.i2c.I2CTransfer.ack_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a list of ack bits for each byte of data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of ints</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.i2c.I2CTransfer.bytes">
<tt class="descname">bytes</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.i2c.I2CTransfer.bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of raw bytes for the transfer including the formatted address</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of ints</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2c.i2c_decode">
<tt class="descclassname">ripyl.protocol.i2c.</tt><tt class="descname">i2c_decode</tt><big>(</big><em>scl</em>, <em>sda</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><big>)</big><a class="headerlink" href="#ripyl.protocol.i2c.i2c_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode an I2C data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>The scl, and sda parameters are edge or sample streams.
Each is a stream of 2-tuples of (time, value) pairs. The type of stream is identified
by the stream_type parameter. Either a series of real valued samples that will be
analyzed to find edge transitions or a set of pre-processed edge transitions
representing the 0 and 1 logic states of the waveforms. When this is a sample
stream, an initial block of data on the scl stream is consumed to determine the most
likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>scl</strong> (<em>sequence of (float, number) pairs</em>) &#8211; An iterable representing the I2C serial clock</li>
<li><strong>sda</strong> (<em>sequence of (float, number) pairs</em>) &#8211; An iterable representing the I2C serial data</li>
<li><strong>logic_levels</strong> (<em>(float, float) or None</em>) &#8211; Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<em>streaming.StreamType</em>) &#8211; <p>Indicates the type of stream used for scl and sda.</p>
<p>When StreamType.Samples, the iterators represent a sequence of samples.
Each sample is a 2-tuple representing the time of the sample and the sample&#8217;s
value. When this type is used, the scl stream is analyzed to determine the
logic levels of the two streams.</p>
<p>When StreamType.Edges, the iterators represent a series of edges.
scl and sda are iterables of 2-tuples representing each edge transition.
The 2-tuples <em>must</em> be in the absolute time form (time, logic level).</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><p>An iterator yielding  a series of StreamRecord-based objects. These will be one of three event types
or two data types. The three events are represented by StreamEvent object with these
obj.kind attribute values:</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;I2C start&#8217;   The start of an I2C transfer</li>
<li>&#8216;I2C restart&#8217; A start condition during a transfer</li>
<li>&#8216;I2C stop&#8217;    The end of a transfer</li>
</ul>
</div></blockquote>
<p>The two data types are represented by the objects I2CAddress and I2CByte. The former
is a 7-bit or 10-bit address from the start of a transfer or restart. The latter contains
the data read or written during the transfer. I2CByte has an attribute ack_bit that
records the value of the ACK for that byte. I2CAddress has a r_wn attribute that indicates
if the transfer is a read or write. The subrecords attribute contains the I2CByte object
or objects that composed the address.</p>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">AutoLevelError when the stream_type is Samples and the logic levels cannot
be determined automatically.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2c.i2c_synth">
<tt class="descclassname">ripyl.protocol.i2c.</tt><tt class="descname">i2c_synth</tt><big>(</big><em>transfers</em>, <em>clock_freq</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.i2c.i2c_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized I2C waveforms</p>
<p>This function simulates I2C transfers on the SCL and SDA signals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>transfers</strong> (<em>sequence of I2CTransfer objects</em>) &#8211; Data to be synthesized.</li>
<li><strong>clock_freq</strong> (<em>float</em>) &#8211; Clock frequency for the I2C bus. Standard rates are 100kHz (100.0e3)
and 400kHz (400.0e3) but any frequency can be specified.</li>
<li><strong>idle_start</strong> (<em>float</em>) &#8211; The amount of idle time before the transmission of transfers begins</li>
<li><strong>idle_end</strong> (<em>float</em>) &#8211; The amount of idle time after the last transfer</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A pair of iterators representing the two edge streams for scl, and sda
respectively. Each edge stream pair is in (time, value) format representing the
time and logic value (0 or 1) for each edge transition. The first elements in the
iterators are the initial state of the waveforms.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.i2c.reconstruct_i2c_transfers">
<tt class="descclassname">ripyl.protocol.i2c.</tt><tt class="descname">reconstruct_i2c_transfers</tt><big>(</big><em>records</em><big>)</big><a class="headerlink" href="#ripyl.protocol.i2c.reconstruct_i2c_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>Recreate I2CTransfer objects using the output of i2c_decode()</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>records</strong> (<em>sequence of I2CByte and I2CAddress</em>) &#8211; An iterable of records produced by i2c_decode().
All StreamEvent records are discarded.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a stream of I2CTransfer objects containing aggregated address and data
from the input records.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.iso_k_line">
<span id="iso-k-line-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">iso_k_line</span></tt> Module<a class="headerlink" href="#module-ripyl.protocol.iso_k_line" title="Permalink to this headline">¶</a></h2>
<p>ISO K-line protocol decoder</p>
<p>Decodes ISO9141 and ISO14230 automotive data bus protocols</p>
<dl class="class">
<dt id="ripyl.protocol.iso_k_line.ISO14230Header">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.iso_k_line.</tt><tt class="descname">ISO14230Header</tt><big>(</big><em>option</em>, <em>target</em>, <em>source</em>, <em>length=None</em><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO14230Header" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>ISO14230 header object</p>
<dl class="docutils">
<dt>Header byte 1: length 0x10nnnnnn</dt>
<dd>5-0 data bytes in message</dd>
</dl>
<p>Header byte 2: optional data byte count if nnnnnn is 0</p>
<p>Header byte 2(3): target address
Header byte 3(4): source address</p>
<dl class="method">
<dt id="ripyl.protocol.iso_k_line.ISO14230Header.bytes">
<tt class="descname">bytes</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO14230Header.bytes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of header bytes in original order</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.ISO9141Header">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.iso_k_line.</tt><tt class="descname">ISO9141Header</tt><big>(</big><em>option</em>, <em>target</em>, <em>source</em><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO9141Header" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>ISO9141 header object</p>
<p>Header byte 1: option</p>
<div class="line-block">
<div class="line-block">
<div class="line">7-5 priority: 000 = high, 111 = low</div>
<div class="line">4   header type: 0 = 3-byte; 1 = 1-byte</div>
<div class="line">3   in frame response: 0 = required (Ford); 1 = not allowed (GM)</div>
<div class="line">2   addressing mode: 1 = physical; 0 = functional</div>
<div class="line">1-0 message type</div>
<div class="line"><br /></div>
</div>
<div class="line">message type:</div>
<div class="line">bit: 3 2 1 0</div>
<div class="line-block">
<div class="line">&#8212;&#8212;-</div>
<div class="line">1 0 0 0 function</div>
<div class="line">1 0 0 1 broadcast</div>
<div class="line">1 0 1 0 query</div>
<div class="line">1 0 1 1 read</div>
<div class="line">1 1 0 0 node-to-node</div>
<div class="line">1 1 0 1 reserved</div>
<div class="line">1 1 1 0 reserved</div>
<div class="line">1 1 1 1 reserved</div>
<div class="line"><br /></div>
</div>
</div>
<p>Header byte 2: target address
Header byte 3: source address</p>
<dl class="method">
<dt id="ripyl.protocol.iso_k_line.ISO9141Header.bytes">
<tt class="descname">bytes</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO9141Header.bytes" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of header bytes in original order</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.ISO9141Init">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.iso_k_line.</tt><tt class="descname">ISO9141Init</tt><big>(</big><em>recs</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.ISO9141Init" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></tt></a></p>
<p>Encapsulates initialization exchange before messaging begins on ISO9141
These are the bytes in the 0x55, key1, key2, ~key2 ~wakeup init sequence.</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.KLineMessage">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.iso_k_line.</tt><tt class="descname">KLineMessage</tt><big>(</big><em>msg_type</em>, <em>header</em>, <em>data</em>, <em>checksum</em><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineMessage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.obd2.OBD2Message" title="ripyl.protocol.obd2.OBD2Message"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.obd2.OBD2Message</span></tt></a></p>
<p>Message object for the K-line protocols ISO9141 and ISO14230</p>
<dl class="method">
<dt id="ripyl.protocol.iso_k_line.KLineMessage.checksum_good">
<tt class="descname">checksum_good</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineMessage.checksum_good" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the message checksum</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A bool that is true when checksum is valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineMessage.end_time">
<tt class="descname">end_time</tt><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineMessage.end_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.iso_k_line.KLineMessage.raw_data">
<tt class="descname">raw_data</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineMessage.raw_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the raw data (minus header and checksum) for the message</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of bytes.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineMessage.start_time">
<tt class="descname">start_time</tt><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineMessage.start_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.KLineProtocol">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.iso_k_line.</tt><tt class="descname">KLineProtocol</tt><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineProtocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for identifying the message protocol</p>
<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineProtocol.ISO14230">
<tt class="descname">ISO14230</tt><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineProtocol.ISO14230" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineProtocol.ISO9141">
<tt class="descname">ISO9141</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineProtocol.ISO9141" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineProtocol.Unknown">
<tt class="descname">Unknown</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineProtocol.Unknown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.KLineStreamMessage">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.iso_k_line.</tt><tt class="descname">KLineStreamMessage</tt><big>(</big><em>msg</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamMessage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.obd2.OBD2StreamMessage" title="ripyl.protocol.obd2.OBD2StreamMessage"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.obd2.OBD2StreamMessage</span></tt></a></p>
<p>StreamMessage object for the K-line protocols ISO9141 and ISO14230</p>
<dl class="classmethod">
<dt id="ripyl.protocol.iso_k_line.KLineStreamMessage.status_text">
<em class="property">classmethod </em><tt class="descname">status_text</tt><big>(</big><em>status</em><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamMessage.status_text" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The string representation of a status code</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.KLineStreamStatus">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.iso_k_line.</tt><tt class="descname">KLineStreamStatus</tt><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for KLineStreamMessage status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineStreamStatus.BadInitError">
<tt class="descname">BadInitError</tt><em class="property"> = 202</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamStatus.BadInitError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineStreamStatus.ChecksumError">
<tt class="descname">ChecksumError</tt><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamStatus.ChecksumError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.iso_k_line.KLineStreamStatus.InvalidMessageError">
<tt class="descname">InvalidMessageError</tt><em class="property"> = 203</em><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineStreamStatus.InvalidMessageError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.iso_k_line.KLineWakeup">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.iso_k_line.</tt><tt class="descname">KLineWakeup</tt><big>(</big><em>bounds</em>, <em>edges</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.KLineWakeup" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></tt></a></p>
<p>Encapsulates BRK data values representing the wakeup pattern</p>
<p>This is used for the slow init (0x33 at 5-baud) and the fast init (25ms low, 25ms high)</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.iso_k_line.iso_k_line_decode">
<tt class="descclassname">ripyl.protocol.iso_k_line.</tt><tt class="descname">iso_k_line_decode</tt><big>(</big><em>stream</em>, <em>min_msg_gap=0.007</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.iso_k_line_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode ISO9141 and ISO14230 data streams</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stream</strong> (<em>sequence of (float, number) pairs</em>) &#8211; A stream of 2-tuples of (time, value) pairs. The type of stream is identified
by the stream_type parameter. Either a series of real valued samples that will
be analyzed to find edge transitions or a set of pre-processed edge transitions
representing the 0 and 1 logic states of the K-Line waveform. When this is a sample
stream, an initial block of data is consumed to determine the most likely logic
levels in the signal.</li>
<li><strong>min_msg_gap</strong> (<em>float</em>) &#8211; The minimum time between bytes for identifying the end and start
of messages. For ISO14230 this is used in addition to the message length encoded
in the header.</li>
<li><strong>logic_levels</strong> (<em>(float, float) or None</em>) &#8211; Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<em>streaming.StreamType</em>) &#8211; A StreamType value indicating that the stream parameter represents either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of UARTFrame objects. Each frame contains subrecords marking the location
of sub-elements within the frame (start, data, stop). BRK conditions are reported as a
data value 0x00 with a framing error in the status code.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.iso_k_line.iso_k_line_synth">
<tt class="descclassname">ripyl.protocol.iso_k_line.</tt><tt class="descname">iso_k_line_synth</tt><big>(</big><em>messages</em>, <em>msg_gap=0.008</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em>, <em>word_interval=0.001</em><big>)</big><a class="headerlink" href="#ripyl.protocol.iso_k_line.iso_k_line_synth" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.lm73">
<span id="lm73-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">lm73</span></tt> Module<a class="headerlink" href="#module-ripyl.protocol.lm73" title="Permalink to this headline">¶</a></h2>
<p>LM73 (temperature sensor) protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.lm73.LM73Operation">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.lm73.</tt><tt class="descname">LM73Operation</tt><a class="headerlink" href="#ripyl.protocol.lm73.LM73Operation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for LM73 bus operations</p>
<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Operation.ReadData">
<tt class="descname">ReadData</tt><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Operation.ReadData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Operation.SetPointer">
<tt class="descname">SetPointer</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Operation.SetPointer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Operation.WriteData">
<tt class="descname">WriteData</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Operation.WriteData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.lm73.LM73Register">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.lm73.</tt><tt class="descname">LM73Register</tt><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for LM73 registers</p>
<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.Configuration">
<tt class="descname">Configuration</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.Configuration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.ControlStatus">
<tt class="descname">ControlStatus</tt><em class="property"> = 4</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.ControlStatus" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.Identification">
<tt class="descname">Identification</tt><em class="property"> = 7</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.Identification" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.THigh">
<tt class="descname">THigh</tt><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.THigh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.TLow">
<tt class="descname">TLow</tt><em class="property"> = 3</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.TLow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Register.Temperature">
<tt class="descname">Temperature</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73Register.Temperature" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.lm73.LM73StreamStatus">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.lm73.</tt><tt class="descname">LM73StreamStatus</tt><a class="headerlink" href="#ripyl.protocol.lm73.LM73StreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration of LM73 status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73StreamStatus.MissingDataError">
<tt class="descname">MissingDataError</tt><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.lm73.LM73StreamStatus.MissingDataError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.lm73.LM73Transfer">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.lm73.</tt><tt class="descname">LM73Transfer</tt><big>(</big><em>address</em>, <em>op</em>, <em>reg=0</em>, <em>data=None</em><big>)</big><a class="headerlink" href="#ripyl.protocol.lm73.LM73Transfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></tt></a></p>
<p>Represent a transaction for the LM73</p>
<dl class="attribute">
<dt id="ripyl.protocol.lm73.LM73Transfer.temperature">
<tt class="descname">temperature</tt><a class="headerlink" href="#ripyl.protocol.lm73.LM73Transfer.temperature" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the temperature in Celcius</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A float</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.lm73.lm73_decode">
<tt class="descclassname">ripyl.protocol.lm73.</tt><tt class="descname">lm73_decode</tt><big>(</big><em>stream</em>, <em>addresses=set([72</em>, <em>73</em>, <em>74</em>, <em>76</em>, <em>77</em>, <em>78])</em><big>)</big><a class="headerlink" href="#ripyl.protocol.lm73.lm73_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode an LM73 data stream</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stream</strong> (<em>sequence of StreamRecord or I2CTransfer</em>) &#8211; An iterable representing either a stream of I2C StreamRecord objects or
I2CTransfer objects produced by i2c_decode() or reconstruct_i2c_transfers() respectively.</li>
<li><strong>addresses</strong> (<em>set of ints</em>) &#8211; A collection identifying the valid LM73 addresses to decode. All others are ignored.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of LM73Transfer objects and any unrelated I2CTransfer objects.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.obd2">
<span id="obd2-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">obd2</span></tt> Module<a class="headerlink" href="#module-ripyl.protocol.obd2" title="Permalink to this headline">¶</a></h2>
<p>OBD-2 protocol support</p>
<dl class="class">
<dt id="ripyl.protocol.obd2.OBD2Message">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.obd2.</tt><tt class="descname">OBD2Message</tt><big>(</big><em>msg_type</em><big>)</big><a class="headerlink" href="#ripyl.protocol.obd2.OBD2Message" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Abstract base class for OBD-2 messages</p>
<p>This is to be specialized in each protocol implementation.</p>
<dl class="method">
<dt id="ripyl.protocol.obd2.OBD2Message.checksum_good">
<tt class="descname">checksum_good</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.obd2.OBD2Message.checksum_good" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the message checksum</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A bool that is true when checksum is valid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2Message.end_time">
<tt class="descname">end_time</tt><a class="headerlink" href="#ripyl.protocol.obd2.OBD2Message.end_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.protocol.obd2.OBD2Message.raw_data">
<tt class="descname">raw_data</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.obd2.OBD2Message.raw_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the raw data (minus header and checksum) for the message</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A list of bytes.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2Message.start_time">
<tt class="descname">start_time</tt><a class="headerlink" href="#ripyl.protocol.obd2.OBD2Message.start_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.obd2.OBD2MsgType">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.obd2.</tt><tt class="descname">OBD2MsgType</tt><a class="headerlink" href="#ripyl.protocol.obd2.OBD2MsgType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for message types</p>
<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2MsgType.Request">
<tt class="descname">Request</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.obd2.OBD2MsgType.Request" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2MsgType.Response">
<tt class="descname">Response</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.obd2.OBD2MsgType.Response" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2MsgType.Unknown">
<tt class="descname">Unknown</tt><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.obd2.OBD2MsgType.Unknown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.obd2.OBD2StreamMessage">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.obd2.</tt><tt class="descname">OBD2StreamMessage</tt><big>(</big><em>msg</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamMessage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></tt></a></p>
<p>Encapsulates an OBD2Message object into a StreamSegment</p>
<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2StreamMessage.end_time">
<tt class="descname">end_time</tt><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamMessage.end_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2StreamMessage.start_time">
<tt class="descname">start_time</tt><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamMessage.start_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="ripyl.protocol.obd2.OBD2StreamMessage.status_text">
<em class="property">classmethod </em><tt class="descname">status_text</tt><big>(</big><em>status</em><big>)</big><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamMessage.status_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.obd2.OBD2StreamTransfer">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.obd2.</tt><tt class="descname">OBD2StreamTransfer</tt><big>(</big><em>messages</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamTransfer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></tt></a></p>
<p>Represent a collection of messages involved in a request/response transaction.</p>
<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2StreamTransfer.end_time">
<tt class="descname">end_time</tt><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamTransfer.end_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.OBD2StreamTransfer.start_time">
<tt class="descname">start_time</tt><a class="headerlink" href="#ripyl.protocol.obd2.OBD2StreamTransfer.start_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.obd2.PIDTableEntry">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.obd2.</tt><tt class="descname">PIDTableEntry</tt><big>(</big><em>bytes_returned</em>, <em>description</em>, <em>units=''</em>, <em>decoder=None</em><big>)</big><a class="headerlink" href="#ripyl.protocol.obd2.PIDTableEntry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Data structure for string PID decode info</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.obd2.PTE">
<tt class="descclassname">ripyl.protocol.obd2.</tt><tt class="descname">PTE</tt><a class="headerlink" href="#ripyl.protocol.obd2.PTE" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#ripyl.protocol.obd2.PIDTableEntry" title="ripyl.protocol.obd2.PIDTableEntry"><tt class="xref py py-class docutils literal"><span class="pre">PIDTableEntry</span></tt></a></p>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.obd2.decode_dtc">
<tt class="descclassname">ripyl.protocol.obd2.</tt><tt class="descname">decode_dtc</tt><big>(</big><em>dtc</em><big>)</big><a class="headerlink" href="#ripyl.protocol.obd2.decode_dtc" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert encoded DTC to a string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dtc</strong> (<em>int</em>) &#8211; The binary coded DTC.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A string representing the dtc in readable form.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.obd2.decode_obd2_command">
<tt class="descclassname">ripyl.protocol.obd2.</tt><tt class="descname">decode_obd2_command</tt><big>(</big><em>msg_type</em>, <em>raw_data</em><big>)</big><a class="headerlink" href="#ripyl.protocol.obd2.decode_obd2_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode the contents of an OBD-2 message</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>msg_type</strong> (<em>OBD2MsgType</em>) &#8211; The type of message (request or response) to be decoded.</li>
<li><strong>raw_data</strong> (<em>sequence of ints</em>) &#8211; The bytes forming the message</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A 3-tuple containing a string description, a parameter value, and a string for
parameter units. The parameter value is None for request messages and for response
messages with no defined decode routine.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.obd2.reconstruct_obd2_transfers">
<tt class="descclassname">ripyl.protocol.obd2.</tt><tt class="descname">reconstruct_obd2_transfers</tt><big>(</big><em>records</em><big>)</big><a class="headerlink" href="#ripyl.protocol.obd2.reconstruct_obd2_transfers" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate a stream of OBD2StreamMessage objects into OBD2StreamTransfers.</p>
<p>A transfer consists of a request message followed by 0 or more responses from
each ECU on the bus. A new transfer starts with every request message. Objects
other than OBD2StreamMessage are passed through unchanged</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>records</strong> (<em>sequence of OBD2StreamMessage</em>) &#8211; The message objects to reconstruct the transfers from.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a stream of OBD2StreamTransfer objects containing aggregated messages
from the input records and any additional non-message stream objects.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.obd2.register_command_decoder">
<tt class="descclassname">ripyl.protocol.obd2.</tt><tt class="descname">register_command_decoder</tt><big>(</big><em>name</em>, <em>func</em><big>)</big><a class="headerlink" href="#ripyl.protocol.obd2.register_command_decoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a decoder function for additional manufacturer specific SIDs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>string</em>) &#8211; The name of the command set to register the decoder under.</li>
<li><strong>func</strong> (<em>function(OBD2MsgType, (int,...))</em>) &#8211; A Python function object that will be called as a command decoder.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.ps2">
<span id="ps2-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">ps2</span></tt> Module<a class="headerlink" href="#module-ripyl.protocol.ps2" title="Permalink to this headline">¶</a></h2>
<p>PS/2 and AT keyboard protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.ps2.PS2Dir">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.ps2.</tt><tt class="descname">PS2Dir</tt><a class="headerlink" href="#ripyl.protocol.ps2.PS2Dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for PS/2 frame direction</p>
<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2Dir.DeviceToHost">
<tt class="descname">DeviceToHost</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2Dir.DeviceToHost" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2Dir.HostToDevice">
<tt class="descname">HostToDevice</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2Dir.HostToDevice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.ps2.PS2Frame">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.ps2.</tt><tt class="descname">PS2Frame</tt><big>(</big><em>bounds</em>, <em>direction=0</em>, <em>data=None</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.ps2.PS2Frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></tt></a></p>
<p>Frame object for PS/2 data</p>
<dl class="classmethod">
<dt id="ripyl.protocol.ps2.PS2Frame.status_text">
<em class="property">classmethod </em><tt class="descname">status_text</tt><big>(</big><em>status</em><big>)</big><a class="headerlink" href="#ripyl.protocol.ps2.PS2Frame.status_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.ps2.PS2StreamStatus">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.ps2.</tt><tt class="descname">PS2StreamStatus</tt><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration of PS/2 status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2StreamStatus.AckError">
<tt class="descname">AckError</tt><em class="property"> = 203</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamStatus.AckError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2StreamStatus.FramingError">
<tt class="descname">FramingError</tt><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamStatus.FramingError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2StreamStatus.ParityError">
<tt class="descname">ParityError</tt><em class="property"> = 202</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamStatus.ParityError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.ps2.PS2StreamStatus.TimingError">
<tt class="descname">TimingError</tt><em class="property"> = 204</em><a class="headerlink" href="#ripyl.protocol.ps2.PS2StreamStatus.TimingError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.ps2.ps2_decode">
<tt class="descclassname">ripyl.protocol.ps2.</tt><tt class="descname">ps2_decode</tt><big>(</big><em>clk</em>, <em>data</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><big>)</big><a class="headerlink" href="#ripyl.protocol.ps2.ps2_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a PS/2 data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>The clk and data parameters are edge or sample streams.
Each is a stream of 2-tuples of (time, value) pairs. The type of stream is identified
by the stream_type parameter. Either a series of real valued samples that will be
analyzed to find edge transitions or a set of pre-processed edge transitions
representing the 0 and 1 logic states of the waveforms. When this is a sample
stream, an initial block of data on the clk stream is consumed to determine the most
likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clk</strong> (<em>sequence of (float, number) pairs</em>) &#8211; PS/2 clk stream</li>
<li><strong>data</strong> (<em>sequence of (float, number) pairs</em>) &#8211; PS/2 data stream.</li>
<li><strong>logic_levels</strong> (<em>(float, float) or None</em>) &#8211; Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<em>streaming.StreamType</em>) &#8211; A StreamType value indicating that the clk and data parameters represent either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of PS2Frame objects.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if stream_type = Samples and the logic levels cannot
be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.ps2.ps2_synth">
<tt class="descclassname">ripyl.protocol.ps2.</tt><tt class="descname">ps2_synth</tt><big>(</big><em>bytes</em>, <em>direction</em>, <em>clock_freq</em>, <em>idle_start=0.0</em>, <em>word_interval=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.ps2.ps2_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized PS/2 waveform</p>
<p>This function simulates a transmission of data over PS/2.</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bytes</strong> (<em>sequence of int</em>) &#8211; A sequence of bytes that will be transmitted serially</li>
<li><strong>direction</strong> (<em>PS2Dir or a sequence of PS2Dir</em>) &#8211; If a scalar, the direction for all bytes transmitted.
If a sequence of PS2Dir values, the direction of each corresponding
byte in the bytes sequence.</li>
<li><strong>clock_freq</strong> (<em>float</em>) &#8211; The PS/2 clock frequency. 10kHz - 13KHz typ.</li>
<li><strong>idle_start</strong> (<em>float</em>) &#8211; The amount of idle time before the transmission of data begins</li>
<li><strong>word_interval</strong> (<em>float</em>) &#8211; The amount of time between data bytes</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a set of pairs representing the two edge streams for clk and data
respectively. Each edge stream pair is in (time, value) format representing the
time and logic value (0 or 1) for each edge transition. The first set of pairs
yielded is the initial state of the waveforms.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.sagem_ecu">
<span id="sagem-ecu-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">sagem_ecu</span></tt> Module<a class="headerlink" href="#module-ripyl.protocol.sagem_ecu" title="Permalink to this headline">¶</a></h2>
<p>Sagem ECU protocol support</p>
<p>This module should be included along with ripyl.protocol.obd2.
The Sagem decode functions will be registered with the OBD-2 decoder
and are accessed through obd2.decode_obd2_command().</p>
<dl class="function">
<dt id="ripyl.protocol.sagem_ecu.decode_sag_msg">
<tt class="descclassname">ripyl.protocol.sagem_ecu.</tt><tt class="descname">decode_sag_msg</tt><big>(</big><em>sid</em>, <em>pid_table</em>, <em>pid_size</em>, <em>msg_type</em>, <em>raw_data</em><big>)</big><a class="headerlink" href="#ripyl.protocol.sagem_ecu.decode_sag_msg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.spi">
<span id="spi-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">spi</span></tt> Module<a class="headerlink" href="#module-ripyl.protocol.spi" title="Permalink to this headline">¶</a></h2>
<p>SPI protocol decoder</p>
<dl class="class">
<dt id="ripyl.protocol.spi.SPIFrame">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.spi.</tt><tt class="descname">SPIFrame</tt><big>(</big><em>bounds</em>, <em>data=None</em><big>)</big><a class="headerlink" href="#ripyl.protocol.spi.SPIFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></tt></a></p>
<p>Frame object for SPI data</p>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.spi.spi_decode">
<tt class="descclassname">ripyl.protocol.spi.</tt><tt class="descname">spi_decode</tt><big>(</big><em>clk</em>, <em>data_io</em>, <em>cs=None</em>, <em>cpol=0</em>, <em>cpha=0</em>, <em>lsb_first=True</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><big>)</big><a class="headerlink" href="#ripyl.protocol.spi.spi_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode an SPI data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>The clk, data_io, and cs parameters are edge or sample streams.
Each is a stream of 2-tuples of (time, value) pairs. The type of stream is identified
by the stream_type parameter. Either a series of real valued samples that will be
analyzed to find edge transitions or a set of pre-processed edge transitions
representing the 0 and 1 logic states of the waveforms. When this is a sample
stream, an initial block of data on the clk stream is consumed to determine the most
likely logic levels in the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clk</strong> (<em>sequence of (float, number) pairs</em>) &#8211; SPI clk stream</li>
<li><strong>data_io</strong> (<em>sequence of (float, number) pairs</em>) &#8211; SPI MOSI or MISO stream.</li>
<li><strong>cs</strong> (<em>sequence of (float, float) pairs</em>) &#8211; SPI chip select stream. Can be None if cs is not available.</li>
<li><strong>cpol</strong> (<em>int</em>) &#8211; Clock polarity: 0 or 1 (the idle state of the clock signal)</li>
<li><strong>cpha</strong> (<em>int</em>) &#8211; Clock phase: 0 or 1 (data is sampled on the 1st clock edge (0) or the 2nd (1))</li>
<li><strong>lsb_first</strong> (<em>bool</em>) &#8211; Flag indicating whether the Least Significant Bit is transmitted first.</li>
<li><strong>logic_levels</strong> (<em>(float, float) or None</em>) &#8211; Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<em>streaming.StreamType</em>) &#8211; A StreamType value indicating that the clk, data_io, and cs parameters represent either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of SPIFrame objects.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if stream_type = Samples and the logic levels cannot
be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.spi.spi_synth">
<tt class="descclassname">ripyl.protocol.spi.</tt><tt class="descname">spi_synth</tt><big>(</big><em>data</em>, <em>word_size</em>, <em>clock_freq</em>, <em>cpol=0</em>, <em>cpha=0</em>, <em>lsb_first=True</em>, <em>idle_start=0.0</em>, <em>word_interval=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.spi.spi_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized SPI waveform</p>
<p>This function simulates a transmission of data over SPI.</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>sequence of int</em>) &#8211; A sequence of words that will be transmitted serially</li>
<li><strong>word_size</strong> (<em>int</em>) &#8211; The number of bits in each word</li>
<li><strong>clock_freq</strong> (<em>float</em>) &#8211; The SPI clock frequency</li>
<li><strong>cpol</strong> (<em>int</em>) &#8211; Clock polarity: 0 or 1</li>
<li><strong>cpha</strong> (<em>int</em>) &#8211; Clock phase: 0 or 1</li>
<li><strong>lsb_first</strong> (<em>bool</em>) &#8211; Flag indicating whether the Least Significant Bit is transmitted first.</li>
<li><strong>idle_start</strong> (<em>float</em>) &#8211; The amount of idle time before the transmission of data begins</li>
<li><strong>word_interval</strong> (<em>float</em>) &#8211; The amount of time between data words</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a triplet of pairs representing the three edge streams for clk, data_io, and cs
respectively. Each edge stream pair is in (time, value) format representing the
time and logic value (0 or 1) for each edge transition. The first set of pairs
yielded is the initial state of the waveforms.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.uart">
<span id="uart-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">uart</span></tt> Module<a class="headerlink" href="#module-ripyl.protocol.uart" title="Permalink to this headline">¶</a></h2>
<p>UART protocol decoder</p>
<dl class="exception">
<dt id="ripyl.protocol.uart.AutoBaudError">
<em class="property">exception </em><tt class="descclassname">ripyl.protocol.uart.</tt><tt class="descname">AutoBaudError</tt><a class="headerlink" href="#ripyl.protocol.uart.AutoBaudError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamError" title="ripyl.streaming.StreamError"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamError</span></tt></a></p>
<p>Error for failed baud rate detection</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.uart.UARTConfig">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.uart.</tt><tt class="descname">UARTConfig</tt><a class="headerlink" href="#ripyl.protocol.uart.UARTConfig" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration of configuration settings</p>
<dl class="attribute">
<dt id="ripyl.protocol.uart.UARTConfig.IdleHigh">
<tt class="descname">IdleHigh</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.uart.UARTConfig.IdleHigh" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.uart.UARTConfig.IdleLow">
<tt class="descname">IdleLow</tt><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.uart.UARTConfig.IdleLow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.uart.UARTFrame">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.uart.</tt><tt class="descname">UARTFrame</tt><big>(</big><em>bounds</em>, <em>data=None</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.uart.UARTFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></tt></a></p>
<p>Frame object for UART data</p>
<dl class="classmethod">
<dt id="ripyl.protocol.uart.UARTFrame.status_text">
<em class="property">classmethod </em><tt class="descname">status_text</tt><big>(</big><em>status</em><big>)</big><a class="headerlink" href="#ripyl.protocol.uart.UARTFrame.status_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.uart.UARTStreamStatus">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.uart.</tt><tt class="descname">UARTStreamStatus</tt><a class="headerlink" href="#ripyl.protocol.uart.UARTStreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration of UART status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.uart.UARTStreamStatus.FramingError">
<tt class="descname">FramingError</tt><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.uart.UARTStreamStatus.FramingError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.uart.UARTStreamStatus.ParityError">
<tt class="descname">ParityError</tt><em class="property"> = 202</em><a class="headerlink" href="#ripyl.protocol.uart.UARTStreamStatus.ParityError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.uart.uart_decode">
<tt class="descclassname">ripyl.protocol.uart.</tt><tt class="descname">uart_decode</tt><big>(</big><em>stream</em>, <em>bits=8</em>, <em>parity=None</em>, <em>stop_bits=1.0</em>, <em>lsb_first=True</em>, <em>polarity=1</em>, <em>baud_rate=None</em>, <em>use_std_baud=True</em>, <em>logic_levels=None</em>, <em>stream_type=1</em>, <em>baud_deque=None</em><big>)</big><a class="headerlink" href="#ripyl.protocol.uart.uart_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a UART data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stream</strong> (<em>sequence of (float, number) pairs</em>) &#8211; A stream of 2-tuples of (time, value) pairs. The type of stream is identified
by the stream_type parameter. Either a series of real valued samples that will
be analyzed to find edge transitions or a set of pre-processed edge transitions
representing the 0 and 1 logic states of the UART waveform. When this is a sample
stream, an initial block of data is consumed to determine the most likely logic
levels in the signal.</li>
<li><strong>bits</strong> (<em>int</em>) &#8211; The number of bits in each word. Typically 5, 7, 8, or 9.</li>
<li><strong>parity</strong> (<em>string or None</em>) &#8211; The type of parity to use. One of None, &#8216;even&#8217;, or &#8216;odd&#8217;</li>
<li><strong>stop_bits</strong> (<em>number</em>) &#8211; The number of stop bits. Typically 1, 1.5, or 2</li>
<li><strong>lsb_first</strong> (<em>bool</em>) &#8211; Flag indicating whether the Least Significant Bit is transmitted first.</li>
<li><strong>inverted</strong> (<em>bool</em>) &#8211; Flag indicating if the signal levels have been inverted from their logical
meaning. Use this when the input stream derives from an inverting driver such
as those used for RS-232.</li>
<li><strong>polarity</strong> (<em>UARTConfig</em>) &#8211; Set the polarity (idle state high or low).</li>
<li><strong>baud_rate</strong> (<em>int</em>) &#8211; The baud rate of the stream. If None, the first 50 edges will be analyzed to
automatically determine the most likely baud rate for the stream. On average
50 edges will occur after 11 frames have been captured.</li>
<li><strong>use_std_baud</strong> (<em>bool</em>) &#8211; Flag that forces coercion of automatically detected baud rate to the set of
standard rates</li>
<li><strong>logic_levels</strong> (<em>(float, float) or None</em>) &#8211; Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<em>streaming.StreamType</em>) &#8211; A StreamType value indicating that the stream parameter represents either Samples
or Edges</li>
<li><strong>baud_deque</strong> (<em>collections.deque or None</em>) &#8211; An optional collections.deque object that is used to monitor the results of
automatic baud detection. A dict containing the internal variables baud_rate
and raw_symbol_rate is placed on the deque when uart_decode() is called.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of UARTFrame objects. Each frame contains subrecords marking the location
of sub-elements within the frame (start, data, parity, stop). Parity errors are recorded
as an error status in the parity subrecord. BRK conditions are reported as a data value
0x00 with a framing error in the status code.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first">AutoLevelError if stream_type = Samples and the logic levels cannot
be determined.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first">AutoBaudError if auto-baud is active and the baud rate cannot
be determined.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">ValueError if the parity argument is invalid.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.uart.uart_synth">
<tt class="descclassname">ripyl.protocol.uart.</tt><tt class="descname">uart_synth</tt><big>(</big><em>data</em>, <em>bits=8</em>, <em>baud=115200</em>, <em>parity=None</em>, <em>stop_bits=1.0</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em>, <em>word_interval=1e-05</em><big>)</big><a class="headerlink" href="#ripyl.protocol.uart.uart_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized UART waveform</p>
<p>This function simulates a single, unidirectional channel of a UART serial
connection. Its output is analagous to txd. The signal is generated with
idle-high polarity.</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>sequence of int</em>) &#8211; A sequence of words that will be transmitted serially</li>
<li><strong>bits</strong> (<em>int</em>) &#8211; The number of bits in each word. Typically 5, 7, 8, or 9.</li>
<li><strong>baud</strong> (<em>int</em>) &#8211; The baud rate</li>
<li><strong>parity</strong> (<em>string or None</em>) &#8211; The type of parity to use. One of None, &#8216;even&#8217;, or &#8216;odd&#8217;</li>
<li><strong>stop_bits</strong> (<em>number</em>) &#8211; The number of stop bits. Typically 1, 1.5, or 2</li>
<li><strong>idle_start</strong> (<em>float</em>) &#8211; The amount of idle time before the transmission of data begins</li>
<li><strong>idle_end</strong> (<em>float</em>) &#8211; The amount of idle time after the transmission of data ends</li>
<li><strong>word_interval</strong> (<em>float</em>) &#8211; The amount of time between data words</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of 2-tuples (time, value) representing the time and
logic value (0 or 1) for each edge transition on txd. The first tuple
yielded is the initial state of the waveform. All remaining
tuples are edges where the txd state changes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.usb">
<span id="usb-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">usb</span></tt> Module<a class="headerlink" href="#module-ripyl.protocol.usb" title="Permalink to this headline">¶</a></h2>
<p>USB protocol decoder</p>
<p>This Supports all of USB 2.0 including Low, Full, and High speed;
Link Power Management extended tokens; and USB 1.x mixed Low and
Full speed transmissions. HSIC protocol is also supported.</p>
<dl class="class">
<dt id="ripyl.protocol.usb.USBDataPacket">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBDataPacket</tt><big>(</big><em>pid</em>, <em>data</em>, <em>speed=1</em>, <em>delay=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBDataPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></tt></a></p>
<p>Data packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBDataPacket.field_offsets">
<tt class="descname">field_offsets</tt><big>(</big><em>with_stuffing=False</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBDataPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) &#8211; Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBDataPacket.get_bits">
<tt class="descname">get_bits</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBDataPacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate data packet bits</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBEXTPacket">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBEXTPacket</tt><big>(</big><em>pid</em>, <em>addr</em>, <em>endp</em>, <em>sub_pid</em>, <em>variable</em>, <em>speed=1</em>, <em>delay=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBEXTPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></tt></a></p>
<p>Extended packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBEXTPacket.field_offsets">
<tt class="descname">field_offsets</tt><big>(</big><em>with_stuffing=False</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBEXTPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) &#8211; Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBHandshakePacket">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBHandshakePacket</tt><big>(</big><em>pid</em>, <em>speed=1</em>, <em>delay=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBHandshakePacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></tt></a></p>
<p>Handshake packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBHandshakePacket.field_offsets">
<tt class="descname">field_offsets</tt><big>(</big><em>with_stuffing=False</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBHandshakePacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) &#8211; Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBHandshakePacket.get_bits">
<tt class="descname">get_bits</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBHandshakePacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate handshake packet bits</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBPID">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBPID</tt><a class="headerlink" href="#ripyl.protocol.usb.USBPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for the packet PIDs</p>
<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.ACK">
<tt class="descname">ACK</tt><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.ACK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.Data0">
<tt class="descname">Data0</tt><em class="property"> = 3</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.Data0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.Data1">
<tt class="descname">Data1</tt><em class="property"> = 11</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.Data1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.Data2">
<tt class="descname">Data2</tt><em class="property"> = 7</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.Data2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.ERR">
<tt class="descname">ERR</tt><em class="property"> = 12</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.ERR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.EXT">
<tt class="descname">EXT</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.EXT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.MData">
<tt class="descname">MData</tt><em class="property"> = 15</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.MData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.NAK">
<tt class="descname">NAK</tt><em class="property"> = 10</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.NAK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.NYET">
<tt class="descname">NYET</tt><em class="property"> = 6</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.NYET" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.PING">
<tt class="descname">PING</tt><em class="property"> = 4</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.PING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.PRE">
<tt class="descname">PRE</tt><em class="property"> = 12</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.PRE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.SOF">
<tt class="descname">SOF</tt><em class="property"> = 5</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.SOF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.SPLIT">
<tt class="descname">SPLIT</tt><em class="property"> = 8</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.SPLIT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.STALL">
<tt class="descname">STALL</tt><em class="property"> = 14</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.STALL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.TokenIn">
<tt class="descname">TokenIn</tt><em class="property"> = 9</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.TokenIn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.TokenOut">
<tt class="descname">TokenOut</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.TokenOut" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPID.TokenSetup">
<tt class="descname">TokenSetup</tt><em class="property"> = 13</em><a class="headerlink" href="#ripyl.protocol.usb.USBPID.TokenSetup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBPacket">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBPacket</tt><big>(</big><em>pid</em>, <em>speed=1</em>, <em>delay=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for USB packet objects</p>
<p>This class should not be instanced directly. Use the various subclasses instead.</p>
<p>These objects have methods meant to be used by the usb_synth() routine. When
these objects are embedded in a USBStreamPacket object they are used for attribute
access only.</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.field_offsets">
<tt class="descname">field_offsets</tt><big>(</big><em>with_stuffing=None</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.get_bits">
<tt class="descname">get_bits</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the raw data bits of a packet in LSB-first order</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.get_diff_edges">
<tt class="descname">get_diff_edges</tt><big>(</big><em>cur_time=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.get_diff_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a set of edges corresponding to USB differential (D+ - D-) signal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cur_time</strong> (<em>float</em>) &#8211; The starting offset time for the edges</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of differential edges</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.get_edges">
<tt class="descname">get_edges</tt><big>(</big><em>cur_time=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.get_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a set of edges corresponding to USB D+ and D- signals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cur_time</strong> (<em>float</em>) &#8211; The starting offset time for the edges</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A 2-tuple containing the d+ and d- edge lists</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBPacket.get_hsic_edges">
<tt class="descname">get_hsic_edges</tt><big>(</big><em>cur_time=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBPacket.get_hsic_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Produce a set of edges corresponding to USB HSIC (strobe, data) signals</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cur_time</strong> (<em>float</em>) &#8211; The starting offset time for the edges</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A 2-tuple containing the strobe and data edge lists</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBPacketKind">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBPacketKind</tt><a class="headerlink" href="#ripyl.protocol.usb.USBPacketKind" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for packet kind (lower two bits of PID)</p>
<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPacketKind.Data">
<tt class="descname">Data</tt><em class="property"> = 3</em><a class="headerlink" href="#ripyl.protocol.usb.USBPacketKind.Data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPacketKind.Handshake">
<tt class="descname">Handshake</tt><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.usb.USBPacketKind.Handshake" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPacketKind.Special">
<tt class="descname">Special</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.usb.USBPacketKind.Special" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBPacketKind.Token">
<tt class="descname">Token</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.usb.USBPacketKind.Token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBSOFPacket">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBSOFPacket</tt><big>(</big><em>pid</em>, <em>frame_num</em>, <em>speed=1</em>, <em>delay=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBSOFPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></tt></a></p>
<p>Start of Frame packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBSOFPacket.field_offsets">
<tt class="descname">field_offsets</tt><big>(</big><em>with_stuffing=False</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBSOFPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) &#8211; Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBSOFPacket.get_bits">
<tt class="descname">get_bits</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBSOFPacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate SOF packet bits</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBSpeed">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBSpeed</tt><a class="headerlink" href="#ripyl.protocol.usb.USBSpeed" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for the USB bus speeds</p>
<dl class="attribute">
<dt id="ripyl.protocol.usb.USBSpeed.FullSpeed">
<tt class="descname">FullSpeed</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.usb.USBSpeed.FullSpeed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBSpeed.HighSpeed">
<tt class="descname">HighSpeed</tt><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.usb.USBSpeed.HighSpeed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBSpeed.LowSpeed">
<tt class="descname">LowSpeed</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.usb.USBSpeed.LowSpeed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBSplitPacket">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBSplitPacket</tt><big>(</big><em>pid</em>, <em>addr</em>, <em>sc</em>, <em>port</em>, <em>s</em>, <em>e</em>, <em>et</em>, <em>speed=2</em>, <em>delay=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBSplitPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></tt></a></p>
<p>Split packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBSplitPacket.field_offsets">
<tt class="descname">field_offsets</tt><big>(</big><em>with_stuffing=False</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBSplitPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) &#8211; Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBSplitPacket.get_bits">
<tt class="descname">get_bits</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBSplitPacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate split packet bits</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBState">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBState</tt><a class="headerlink" href="#ripyl.protocol.usb.USBState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for logical bus states</p>
<dl class="attribute">
<dt id="ripyl.protocol.usb.USBState.J">
<tt class="descname">J</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.protocol.usb.USBState.J" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBState.K">
<tt class="descname">K</tt><em class="property"> = 2</em><a class="headerlink" href="#ripyl.protocol.usb.USBState.K" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBState.SE0">
<tt class="descname">SE0</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.protocol.usb.USBState.SE0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBState.SE1">
<tt class="descname">SE1</tt><em class="property"> = 3</em><a class="headerlink" href="#ripyl.protocol.usb.USBState.SE1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBStreamError">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBStreamError</tt><big>(</big><em>bounds</em>, <em>error_data</em>, <em>pid=-1</em>, <em>status=200</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBStreamError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></tt></a></p>
<p>Contains partially decoded packet data after an error has been found
in the data stream</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBStreamPacket">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBStreamPacket</tt><big>(</big><em>bounds</em>, <em>sop_end</em>, <em>packet</em>, <em>crc=None</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBStreamPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamSegment" title="ripyl.streaming.StreamSegment"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamSegment</span></tt></a></p>
<p>Encapsulates a USBPacket object (see below) into a StreamSegment</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBStreamPacket.field_offsets">
<tt class="descname">field_offsets</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBStreamPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive times for the start and end of a field.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="ripyl.protocol.usb.USBStreamPacket.status_text">
<em class="property">classmethod </em><tt class="descname">status_text</tt><big>(</big><em>status</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBStreamPacket.status_text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBStreamStatus">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBStreamStatus</tt><a class="headerlink" href="#ripyl.protocol.usb.USBStreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for USBStreamPacket and USBStreamError status codes</p>
<dl class="attribute">
<dt id="ripyl.protocol.usb.USBStreamStatus.BitStuffingError">
<tt class="descname">BitStuffingError</tt><em class="property"> = 203</em><a class="headerlink" href="#ripyl.protocol.usb.USBStreamStatus.BitStuffingError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBStreamStatus.CRCError">
<tt class="descname">CRCError</tt><em class="property"> = 204</em><a class="headerlink" href="#ripyl.protocol.usb.USBStreamStatus.CRCError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBStreamStatus.MissingEOPError">
<tt class="descname">MissingEOPError</tt><em class="property"> = 202</em><a class="headerlink" href="#ripyl.protocol.usb.USBStreamStatus.MissingEOPError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb.USBStreamStatus.ShortPacketError">
<tt class="descname">ShortPacketError</tt><em class="property"> = 201</em><a class="headerlink" href="#ripyl.protocol.usb.USBStreamStatus.ShortPacketError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.protocol.usb.USBTokenPacket">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">USBTokenPacket</tt><big>(</big><em>pid</em>, <em>addr</em>, <em>endp</em>, <em>speed=1</em>, <em>delay=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBTokenPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.protocol.usb.USBPacket" title="ripyl.protocol.usb.USBPacket"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.protocol.usb.USBPacket</span></tt></a></p>
<p>Token packet</p>
<dl class="method">
<dt id="ripyl.protocol.usb.USBTokenPacket.field_offsets">
<tt class="descname">field_offsets</tt><big>(</big><em>with_stuffing=False</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBTokenPacket.field_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dict of packet field bit offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>with_stuffing</strong> (<em>bool</em>) &#8211; Flag indicating whether to return fields adjusted for stuffed bits</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A dict keyed by the field name and a pair (start, end) for each value.
Start and end are the inclusive bit offsets for the start and end of a field
relative to the end of SOP.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.protocol.usb.USBTokenPacket.get_bits">
<tt class="descname">get_bits</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.USBTokenPacket.get_bits" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate token packet bits</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.table_usb_crc16">
<tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">table_usb_crc16</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.table_usb_crc16" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate USB CRC-16 on data</p>
<p>This is a table-based byte-wise implementation</p>
<dl class="docutils">
<dt>d (sequence of int)</dt>
<dd>Array of integers representing bytes</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Array of integers for each bit in the crc with lsb first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_crc16">
<tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">usb_crc16</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.usb_crc16" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate USB CRC-16 on data</p>
<dl class="docutils">
<dt>d (sequence of int)</dt>
<dd>Array of integers representing 0 or 1 bits in transmission order</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Array of integers for each bit in the crc with lsb first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_crc5">
<tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">usb_crc5</tt><big>(</big><em>d</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.usb_crc5" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate USB CRC-5 on data</p>
<dl class="docutils">
<dt>d (sequence of int)</dt>
<dd>Array of integers representing 0 or 1 bits in transmission order</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Array of integers for each bit in the crc with lsb first</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_decode">
<tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">usb_decode</tt><big>(</big><em>dp</em>, <em>dm</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.usb_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a USB data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>This function decodes USB data captured from the two single-ended D+ and D- signals.
For differential USB decode see the function usb_diff_decode().</p>
<p>Low speed device keep-alive EOPs are not reported in the decoded results.</p>
<p>The dp and dm parameters are edge or sample streams.
Each is a stream of 2-tuples of (time, value) pairs. The type of stream is identified
by the stream_type parameter. Either a series of real valued samples that will be
analyzed to find edge transitions or a set of pre-processed edge transitions
representing the 0 and 1 logic states of the waveforms. When this is a sample
stream, an initial block of data on the dp stream is consumed to determine the most
likely logic levels in the signal and the bus speed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dp</strong> (<em>sequence of (float, number) pairs</em>) &#8211; USB D+ stream</li>
<li><strong>dm</strong> (<em>sequence of (float, number) pairs</em>) &#8211; USB D- stream</li>
<li><strong>logic_levels</strong> (<em>(float, float) or None</em>) &#8211; Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<em>streaming.StreamType</em>) &#8211; A StreamType value indicating that the dp, and dm parameters represent either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of USBStreamPacket and USBStreamError objects</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if stream_type = Samples and the logic levels cannot
be determined. Also if the bus speed cannot be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_diff_decode">
<tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">usb_diff_decode</tt><big>(</big><em>d_diff</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.usb_diff_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a differential USB data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>This function decodes USB data captured from a differential (D+)-(D-) signal.
For single-ended USB decode see the function usb_decode().</p>
<p>Low speed device keep-alive EOPs are not reported in the decoded results.</p>
<p>The d_diff parameter is a stream of 2-tuples of (time, value) pairs. The type of stream
is identified by the stream_type parameter. Either a series of real valued samples that
will be analyzed to find edge transitions or a set of pre-processed edge transitions
representing the -1, 0, and 1 logic states of the differential waveform. When this is a
sample stream, an initial block of data is consumed to determine the most
likely logic levels in the signal and the bus speed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>d_diff</strong> (<em>sequence of (float, number) pairs</em>) &#8211; USB differential D stream</li>
<li><strong>logic_levels</strong> (<em>(float, float) or None</em>) &#8211; Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<em>streaming.StreamType</em>) &#8211; A StreamType value indicating that the dp, and dm parameters represent either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of USBStreamPacket and USBStreamError objects</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if stream_type = Samples and the logic levels cannot
be determined. Also if the bus speed cannot be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_diff_synth">
<tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">usb_diff_synth</tt><big>(</big><em>packets</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.usb_diff_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized differential USB waveforms</p>
<p>This function simulates USB packet transmission on the differential D+ - D-
signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>packets</strong> (<em>sequence of USBPacket</em>) &#8211; The packet objects that are to be simulated</li>
<li><strong>idle_start</strong> (<em>float</em>) &#8211; The amount of idle time before the transmission of packets begins</li>
<li><strong>idle_end</strong> (<em>float</em>) &#8211; The amount of idle time after the last packet</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator of 2-tuples for the d+ - d- differential channel. each
2-tuple is a (time, value) pair representing the time and the
logic value (-1, 0, or 1) for each edge transition. The first tuple
yielded is the initial state of the waveform. All remaining tuples are
edges where the state changes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_hsic_decode">
<tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">usb_hsic_decode</tt><big>(</big><em>strobe</em>, <em>data</em>, <em>logic_levels=None</em>, <em>stream_type=1</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.usb_hsic_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a USB HSIC data stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
processing operations.</p>
<p>This function decodes USB HSIC data captured from the two single-ended strobe and data
signals.</p>
<p>The strobe and data parameters are edge or sample streams.
Each is a stream of 2-tuples of (time, value) pairs. The type of stream is identified
by the stream_type parameter. Either a series of real valued samples that will be
analyzed to find edge transitions or a set of pre-processed edge transitions
representing the 0 and 1 logic states of the waveforms. When this is a sample
stream, an initial block of data on the strobe stream is consumed to determine the most
likely logic levels in the signal. The bus speed is fixed at 480Mb/s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>strobe</strong> (<em>sequence of (float, number) pairs</em>) &#8211; HSIC strobe stream</li>
<li><strong>data</strong> (<em>sequence of (float, number) pairs</em>) &#8211; HSIC data stream</li>
<li><strong>logic_levels</strong> (<em>(float, float) or None</em>) &#8211; Optional pair that indicates (low, high) logic levels of the sample
stream. When present, auto level detection is disabled. This has no effect on
edge streams.</li>
<li><strong>stream_type</strong> (<em>streaming.StreamType</em>) &#8211; A StreamType value indicating that the strobe, and data parameters represent either Samples
or Edges</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of USBStreamPacket and USBStreamError objects</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if stream_type = Samples and the logic levels cannot
be determined.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_hsic_synth">
<tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">usb_hsic_synth</tt><big>(</big><em>packets</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.usb_hsic_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized USB HSIC waveforms</p>
<p>This function simulates USB packet transmission on the HSIC strobe and data signals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>packets</strong> (<em>sequence of USBPacket</em>) &#8211; The packet objects that are to be simulated</li>
<li><strong>idle_start</strong> (<em>float</em>) &#8211; The amount of idle time before the transmission of packets begins</li>
<li><strong>idle_end</strong> (<em>float</em>) &#8211; The amount of idle time after the last packet</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A pair of iterators (strobe, data) for the strobe and data channels. each
iterator is a 2-tuple (time, value) representing the time and the
logic value (0 or 1) for each edge transition on strobe and data. The first tuple
yielded is the initial state of the waveform. All remaining tuples are
edges where the state changes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb.usb_synth">
<tt class="descclassname">ripyl.protocol.usb.</tt><tt class="descname">usb_synth</tt><big>(</big><em>packets</em>, <em>idle_start=0.0</em>, <em>idle_end=0.0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb.usb_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate synthesized USB waveforms</p>
<p>This function simulates USB packet transmission on the D+ and D- signals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>packets</strong> (<em>sequence of USBPacket</em>) &#8211; The packet objects that are to be simulated</li>
<li><strong>idle_start</strong> (<em>float</em>) &#8211; The amount of idle time before the transmission of packets begins</li>
<li><strong>idle_end</strong> (<em>float</em>) &#8211; The amount of idle time after the last packet</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A pair of iterators (dp, dm) for the d+ and d- channels. each
iterator is a 2-tuple (time, value) representing the time and the
logic value (0 or 1) for each edge transition on D+ and D-. The first tuple
yielded is the initial state of the waveform. All remaining tuples are
edges where the state changes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.protocol.usb_transact">
<span id="usb-transact-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">usb_transact</span></tt> Module<a class="headerlink" href="#module-ripyl.protocol.usb_transact" title="Permalink to this headline">¶</a></h2>
<p>USB transaction decoder</p>
<p>Processes a USB packet stream into a set of USBTransaction objects</p>
<dl class="class">
<dt id="ripyl.protocol.usb_transact.USBTransaction">
<em class="property">class </em><tt class="descclassname">ripyl.protocol.usb_transact.</tt><tt class="descname">USBTransaction</tt><big>(</big><em>packets</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb_transact.USBTransaction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.html#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></tt></a></p>
<p>Collection of packets forming a USB transaction</p>
<p>The &#8216;subrecords&#8217; attribute is aliased to the &#8216;packets&#8217; attribute.
These &#8220;packets&#8221; are USBStreamPacket objects.</p>
<dl class="attribute">
<dt id="ripyl.protocol.usb_transact.USBTransaction.end_time">
<tt class="descname">end_time</tt><a class="headerlink" href="#ripyl.protocol.usb_transact.USBTransaction.end_time" title="Permalink to this definition">¶</a></dt>
<dd><p>The end time of the last packet</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb_transact.USBTransaction.packets">
<tt class="descname">packets</tt><a class="headerlink" href="#ripyl.protocol.usb_transact.USBTransaction.packets" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of USBStreamPacket objects from this transaction</p>
</dd></dl>

<dl class="attribute">
<dt id="ripyl.protocol.usb_transact.USBTransaction.start_time">
<tt class="descname">start_time</tt><a class="headerlink" href="#ripyl.protocol.usb_transact.USBTransaction.start_time" title="Permalink to this definition">¶</a></dt>
<dd><p>The start time of the first packet</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb_transact.extract_transaction_packets">
<tt class="descclassname">ripyl.protocol.usb_transact.</tt><tt class="descname">extract_transaction_packets</tt><big>(</big><em>records</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb_transact.extract_transaction_packets" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a stream of USB transactions into raw USBPacket objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>records</strong> (<em>sequence of USBTransaction</em>) &#8211; Iterator of USBTransaction objects</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a stream of USBPacket objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.protocol.usb_transact.usb_transactions_decode">
<tt class="descclassname">ripyl.protocol.usb_transact.</tt><tt class="descname">usb_transactions_decode</tt><big>(</big><em>records</em><big>)</big><a class="headerlink" href="#ripyl.protocol.usb_transact.usb_transactions_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a stream of USB packets into transactions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>records</strong> (<em>sequence of USBPacket</em>) &#8211; An iterator containing USBPacket objects as produced by usb.usb_decode()</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a stream of USBTransaction objects containing packets merged into identifiable
transactions. Any non-USBPacket objects in the input stream will also be present as
will SOF packets.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/Ripyl logo 100px.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">protocol Package</a><ul>
<li><a class="reference internal" href="#module-ripyl.protocol.i2c"><tt class="docutils literal"><span class="pre">i2c</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.iso_k_line"><tt class="docutils literal"><span class="pre">iso_k_line</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.lm73"><tt class="docutils literal"><span class="pre">lm73</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.obd2"><tt class="docutils literal"><span class="pre">obd2</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.ps2"><tt class="docutils literal"><span class="pre">ps2</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.sagem_ecu"><tt class="docutils literal"><span class="pre">sagem_ecu</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.spi"><tt class="docutils literal"><span class="pre">spi</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.uart"><tt class="docutils literal"><span class="pre">uart</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.usb"><tt class="docutils literal"><span class="pre">usb</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.protocol.usb_transact"><tt class="docutils literal"><span class="pre">usb_transact</span></tt> Module</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="ripyl.html"
                        title="previous chapter">ripyl Package</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ripyl.util.html"
                        title="next chapter">util Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/apidoc/ripyl.protocol.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ripyl.util.html" title="util Package"
             >next</a> |</li>
        <li class="right" >
          <a href="ripyl.html" title="ripyl Package"
             >previous</a> |</li>
        <li><a href="../index.html">Ripyl 1.0 documentation</a> &raquo;</li>
          <li><a href="modules.html" >ripyl</a> &raquo;</li>
          <li><a href="ripyl.html" >ripyl Package</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Kevin Thibedeau.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>