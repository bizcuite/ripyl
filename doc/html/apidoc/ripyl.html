
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ripyl Package &mdash; Ripyl 1.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/ripyl.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Ripyl 1.1 documentation" href="../index.html" />
    <link rel="up" title="ripyl" href="modules.html" />
    <link rel="next" title="cython Package" href="ripyl.cython.html" />
    <link rel="prev" title="ripyl" href="modules.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ripyl.cython.html" title="cython Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="ripyl"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Ripyl 1.1 documentation</a> &raquo;</li>
          <li><a href="modules.html" accesskey="U">ripyl</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ripyl-package">
<h1>ripyl Package<a class="headerlink" href="#ripyl-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">ripyl</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-ripyl.__init__"></span><p>Ripyl protocol decode library</p>
</div>
<div class="section" id="module-ripyl.config">
<span id="config-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">config</span></tt> Module<a class="headerlink" href="#module-ripyl.config" title="Permalink to this headline">¶</a></h2>
<p>Manage Ripyl configuration data</p>
<dl class="function">
<dt id="ripyl.config.write_config">
<tt class="descclassname">ripyl.config.</tt><tt class="descname">write_config</tt><big>(</big><em>cfg_path</em>, <em>use_cython</em>, <em>cython_prebuild</em><big>)</big><a class="headerlink" href="#ripyl.config.write_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a file for the Ripyl build configuration</p>
</dd></dl>

</div>
<div class="section" id="module-ripyl.decode">
<span id="decode-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">decode</span></tt> Module<a class="headerlink" href="#module-ripyl.decode" title="Permalink to this headline">¶</a></h2>
<p>General routines shared between decoders</p>
<dl class="class">
<dt id="ripyl.decode.EdgeSequence">
<em class="property">class </em><tt class="descclassname">ripyl.decode.</tt><tt class="descname">EdgeSequence</tt><big>(</big><em>edges</em>, <em>time_step</em>, <em>start_time=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Utility class to walk through an edge iterator in arbitrary time steps</p>
<dl class="method">
<dt id="ripyl.decode.EdgeSequence.advance">
<tt class="descname">advance</tt><big>(</big><em>time_step=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Move forward through edges by a given amount of time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time_step</strong> (<em>float</em>) &#8211; The amount of time to move forward. If None, the default
time_step from the constructor is used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.EdgeSequence.advance_to_edge">
<tt class="descname">advance_to_edge</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.advance_to_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance to the next edge in the iterator after the current time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The amount of time advanced as a float.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.EdgeSequence.at_end">
<tt class="descname">at_end</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.at_end" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True when the edge iterator has terminated</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.EdgeSequence.cur_state">
<tt class="descname">cur_state</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.cur_state" title="Permalink to this definition">¶</a></dt>
<dd><p>The logic level of the edge iterator at the current time</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.decode.MultiEdgeSequence">
<em class="property">class </em><tt class="descclassname">ripyl.decode.</tt><tt class="descname">MultiEdgeSequence</tt><big>(</big><em>edge_sets</em>, <em>time_step</em>, <em>start_time=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Utility class to walk through a group of edge iterators in arbitrary time steps</p>
<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.advance">
<tt class="descname">advance</tt><big>(</big><em>time_step=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Move forward through edges by a given amount of time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time_step</strong> (<em>float</em>) &#8211; The amount of time to move forward. If None, the default
time_step from the constructor is used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.advance_to_edge">
<tt class="descname">advance_to_edge</tt><big>(</big><em>channel_name=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.advance_to_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance to the next edge among the edge sets or in a named channel
after the current time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>channel_name</strong> (<em>string</em>) &#8211; If None, the edge sets are advanced to the closest edge after the current
time. if a valid channel name is provided the edge sets are advanced to
the closest edge on that channel.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A tuple (time, channel_name) representing the amount of time advanced
as a float and the name of the channel containing the edge. If there are no
unterminated edge sequences then the tuple (0,0, &#8216;&#8217;) is returned.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body">ValueError if channel_name is invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.at_end">
<tt class="descname">at_end</tt><big>(</big><em>channel_name=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.at_end" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the sequences have ended</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>channel_name</strong> (<em>string</em>) &#8211; The name of the channel to test for termination</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True when the named edge iterator has terminated. if channel_name is
None, returns True when all channels in the set have terminated.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body">ValueError if channel_name is invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.cur_state">
<tt class="descname">cur_state</tt><big>(</big><em>channel_name=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.cur_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current state of the edge sets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>channel_name</strong> (<em>string</em>) &#8211; Name of the channel to retrieve state from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The value of the named channel&#8217;s state. if channel_name is none
the state of all channels is returned as a list.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body">ValueError if channel_name is invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.cur_time">
<tt class="descname">cur_time</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.cur_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current time of the edge sets</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.decode.check_logic_levels">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">check_logic_levels</tt><big>(</big><em>samples</em>, <em>max_samples=20000</em>, <em>buf_size=2000</em><big>)</big><a class="headerlink" href="#ripyl.decode.check_logic_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically determine the logic levels of a digital signal.</p>
<p>This is a wrapper for find_logic_levels() that handles teeing off
a buffered sample stream and raising AutoLevelError when detection
fails.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream. Each element is a SampleChunk containing
an array of samples. This iterator is internally tee&#8217;d and becomes
invalidated for further use. The return value includes a new sample
stream to retrieve samples from.</li>
<li><strong>max_samples</strong> (<em>int</em>) &#8211; The maximum number of samples to consume from the samples iterable.
This should be at least 2x buf_size and will be coerced to that value
if it is less.</li>
<li><strong>buf_size</strong> (<em>int</em>) &#8211; The maximum size of the sample buffer to analyze for logic levels.
This should be less than max_samples.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A 2-tuple (sample steam, logic_levels) representing the buffered sample
stream and a tuple of the detected logic levels of the samples.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">AutoLevelError if less than two peaks are found in the sample histogram.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_bot_top_hist_peaks">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_bot_top_hist_peaks</tt><big>(</big><em>raw_samples</em>, <em>bins</em>, <em>use_kde=False</em>, <em>kde_bw=0.05</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_bot_top_hist_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the bottom and top peaks in a histogram of data sample magnitudes.
These are the left-most and right-most of the two largest peaks in the histogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>raw_samples</strong> (<em>sequence of numbers</em>) &#8211; A sequence representing the population of data samples that will be
analyzed for peaks</li>
<li><strong>bins</strong> (<em>int</em>) &#8211; The number of bins to use for the histogram</li>
<li><strong>use_kde</strong> (<em>bool</em>) &#8211; Boolean indicating whether to construct the histogram from a Kernel Density
Estimate. This is useful for approximating normally distributed peaks on
synthetic data sets lacking noise.</li>
<li><strong>kde_bw</strong> (<em>float</em>) &#8211; Float providing the bandwidth parameter for the KDE</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A 2-tuple (bot, top) representing the bottom and top peaks. the value for
each peak is the center of the histogram bin that represents the midpoint of the
population for that peak.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">None if less than two peaks are found in the histogram</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">ValueError if a KDE cannot be constructed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_differential_edges">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_differential_edges</tt><big>(</big><em>samples</em>, <em>logic</em>, <em>hysteresis=0.1</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_differential_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the edges in a sampled differential digital waveform</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<p>The samples should be from a differential input such that the input signal can
be in one of three states: differential +1, differential -1, or 0.</p>
<p>Note that the output of this function cannot be used directly without further
processing. Transitions from -1 to +1 and vice versa cannot be easily
distinguished from transitions from -/+1 to 0 to +/-1. Short periods in the 0 state
should be removed but this requires knowledge of the minimum time for a 0 state
to be valid. This is performed by the remove_short_diff_0s() function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream. Each element is a SampleChunk containing
an array of samples.</li>
<li><strong>logic</strong> (<em>(float, float)</em>) &#8211; A 2-tuple (low, high) representing the mean logic levels in the sampled waveform
for -1 and +1. The logic level for 0 is assumed to be midway between these two.</li>
<li><strong>hysteresis</strong> (<em>float</em>) &#8211; A value between 0.0 and 1.0 representing the amount of hysteresis the use for
detecting valid edge crossings.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of 2-tuples (time, value) representing the time and
logic value (-1, 0, or 1) for each edge transition. The first tuple
yielded is the initial state of the sampled waveform. All remaining
tuples are detected edges.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if the stream is empty</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_hist_peaks">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_hist_peaks</tt><big>(</big><em>hist</em>, <em>thresh_scale=1.0</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_hist_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all peaks in a histogram
This uses a modification of the method employed by the &#8220;peaks&#8221; function in
LeCroy digital oscilloscopes. The original algorithm is described in various manuals
such as the 9300 WP03 manual or WavePro manual RevC 2002 (p16-14).</p>
<p>This algorithm works well for real world data sets where the histogram peaks are
normally distributed (i.e. there is some noise present in the data set).
For synthetic waveforms lacking noise or any intermediate samples between discrete
logic levels, the statistical measures used to determine the threshold for a peak
are not valid. The threshold t2 ends up being too large and valid peaks may be
excluded. To avoid this problem the histogram can be sampled from a KDE instead or
the thresh_scale parameter can be set to a lower value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>hist</strong> (<em>sequence of int</em>) &#8211; A sequence representing the histogram bin counts. Typically the first parameter
returned by numpy.histogram() or a KDE from scipy.stats.gaussian_kde().</li>
<li><strong>thresh_scale</strong> (<em>float</em>) &#8211; Apply a scale factor to the internal threshold for peak classification.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of peaks where each peak is a 2-tuple representing the
start and end indices of the peak in hist.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_logic_levels">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_logic_levels</tt><big>(</big><em>samples</em>, <em>max_samples=20000</em>, <em>buf_size=2000</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_logic_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically determine the logic levels of a digital signal.</p>
<p>This function consumes up to max_samples from samples in an attempt
to build a buffer containing a representative set of samples at high
and low logic levels. Less than max_samples may be consumed if an edge
is found and the remaining half of the buffer is filled before the
max_samples threshold is reached.</p>
<p>Warning: this function is insensitive to any edge transition that
occurs within the first 100 samples. If the distribution of samples
is heavily skewed toward one level over the other None may be returned.
To be reliable, a set of samples should contain more than one edge or
a solitary edge after the 400th sample.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream. Each element is a SampleChunk containing
an array of samples.</li>
<li><strong>max_samples</strong> (<em>int</em>) &#8211; The maximum number of samples to consume from the samples iterable.
This should be at least 2x buf_size and will be coerced to that value
if it is less.</li>
<li><strong>buf_size</strong> (<em>int</em>) &#8211; The maximum size of the sample buffer to analyze for logic levels.
This should be less than max_samples.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A 2-tuple (low, high) representing the logic levels of the samples</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None if less than two peaks are found in the sample histogram.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_symbol_rate">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_symbol_rate</tt><big>(</big><em>edges</em>, <em>sample_rate=1.0</em>, <em>spectra=2</em>, <em>auto_span_limit=True</em>, <em>max_span_limit=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_symbol_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the base symbol rate from a set of edges</p>
<p>This function depends on the edge data containing a variety of spans between
edges all related to the fundamental symbol rate. The Harmonic Product Spectrum
(HPS) of the edge span values is calculated and used to isolate the fundamental
symbol rate. This function will not work properly on a clock signal containing
a single time span between edges due to the lack of higher fundementals needed
by the HPS unless spectra=1 which effectively disables the HPS operation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edges</strong> (<em>[(float, int)...] or [(int, int)...]</em>) &#8211; <p>An iterable of 2-tuples representing each edge transition.
The tuples are in one of two forms:</p>
<blockquote>
<div><ul>
<li>absolute time  (time, logic level)</li>
<li>sample indexed (index, logic level)</li>
</ul>
</div></blockquote>
<p>This function will consume all elements of the edges iterable.
It must have a finite length</p>
</li>
<li><strong>sample_rate</strong> (<em>float</em>) &#8211; An adjustment to convert the raw symbol rate from samples to time.
If the edges parameter is based on absolute time units then this
should remain the default value of 1.0.</li>
<li><strong>spectra</strong> (<em>int</em>) &#8211; The number of spectra to include in the calculation of the HPS. This
number should not larger than the highest harmonic in the edge span
data.</li>
<li><strong>auto_span_limit</strong> (<em>bool</em>) &#8211; Excessively long edge spans can impair the symbol rate detection by
reducing the resolution of the HPS. They are typically the result of
long idle periods between the interesting parts we want to estimate
the symbol rate from. When this parameter is True, an attempt is made
to find the ideal limit for the spans included in the HPS.</li>
<li><strong>max_span_limit</strong> (<em>int</em>) &#8211; An optional upper limit for span length to include in the HPS.
auto_span_limit must be False for this to take effect.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The estimated symbol rate of the edge data set as an int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">ValueError if there are not enough edge spans to evaluate
a HPS.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.gen_histogram">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">gen_histogram</tt><big>(</big><em>raw_samples</em>, <em>bins</em>, <em>use_kde=False</em>, <em>kde_bw=0.05</em><big>)</big><a class="headerlink" href="#ripyl.decode.gen_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a histogram using either normal binning or a KDE</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>raw_samples</strong> (<em>sequence of numbers</em>) &#8211; A sequence representing the population of data samples that will be
analyzed for peaks</li>
<li><strong>bins</strong> (<em>int</em>) &#8211; The number of bins to use for the histogram</li>
<li><strong>use_kde</strong> (<em>bool</em>) &#8211; Boolean indicating whether to construct the histogram from a Kernel Density
Estimate. This is useful for approximating normally distributed peaks on
synthetic data sets lacking noise.</li>
<li><strong>kde_bw</strong> (<em>float</em>) &#8211; Float providing the bandwidth parameter for the KDE</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A tuple (hist, bin_centers) containing lists of the histogram bins and
the center value of each bin.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">ValueError if a KDE cannot be constructed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.remove_short_diff_0s">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">remove_short_diff_0s</tt><big>(</big><em>diff_edges</em>, <em>min_diff_0_time</em><big>)</big><a class="headerlink" href="#ripyl.decode.remove_short_diff_0s" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter out unwanted differential 0&#8217;s from an edge stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>diff_edges</strong> (<em>iterable of (float, int) tuples</em>) &#8211; An iterable of 2-tuples representing each edge transition.
The 2-tuples <em>must</em> be in the absolute time form (time, logic level).
The logic levels should be in the set (-1, 0, 1) as produced by
find_differential_edges().</li>
<li><strong>min_diff_0_time</strong> (<em>float</em>) &#8211; The threshold for differential 0 states. A diff 0 lasting less than this
threshold will be filtered out of the edge stream.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of 2-tuples (time, value) representing the time and
logic value (-1, 0, or 1) for each edge transition. The first tuple
yielded is the initial state of the sampled waveform. All remaining
tuples are detected edges.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if the stream is empty</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.sigproc">
<span id="sigproc-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">sigproc</span></tt> Module<a class="headerlink" href="#module-ripyl.sigproc" title="Permalink to this headline">¶</a></h2>
<p>General routines for signal processing of streaming waveforms</p>
<dl class="function">
<dt id="ripyl.sigproc.amplify">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">amplify</tt><big>(</big><em>samples</em>, <em>gain=1.0</em>, <em>offset=0.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.amplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply gain and offset to a sample stream</p>
<p>This modifies samples such that output = input * gain + offset.</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</li>
<li><strong>gain</strong> (<em>float</em>) &#8211; The gain multiplier for the samples</li>
<li><strong>offset</strong> (<em>float</em>) &#8211; The additive offset for the samples</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.approximate_bandwidth">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">approximate_bandwidth</tt><big>(</big><em>rise_time</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.approximate_bandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine an approximate bandwidth for a signal with a known rise time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rise_time</strong> (<em>float</em>) &#8211; A rise time to compute bandwidth from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The bandwidth for the rise time.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.capacify">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">capacify</tt><big>(</big><em>samples</em>, <em>capacitance</em>, <em>resistance=50.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.capacify" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate an RC filter on a waveform:</p>
<div class="highlight-python"><pre>: samples &gt;--R--+--&gt; out
:               |
:               C
:              _|_</pre>
</div>
<p>Warning: This function becomes unstable for small time constants (C * R).
It is implemented with a simple application of the RC difference equations.
The time step (dt) is taken from the sample period of each sample chunk
The results will be inaccurate for large values of dt but still largely
representative of the expected behavior.</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</li>
<li><strong>capacitance</strong> (<em>float</em>) &#8211; The capacitance value</li>
<li><strong>resistance</strong> (<em>float</em>) &#8211; The resistance value</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.chain">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">chain</tt><big>(</big><em>stream_gap_time</em>, <em>*streams</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine a sequence of sample streams together.</p>
<p>A set of sample streams are concatenated together with updated time
stamps to maintain monotonically increasing time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stream_gap_time</strong> (<em>float</em>) &#8211; The time interval added between successive streams</li>
<li><strong>streams</strong> (<em>sequence of iterables containing SampleChunk objects</em>) &#8211; A sequence of streams</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream representing the data from each stream in order</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.chain_edges">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">chain_edges</tt><big>(</big><em>stream_gap_time</em>, <em>*streams</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.chain_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine a sequence of edge streams together.</p>
<p>A set of edge streams are concatenated together with updated time
stamps to maintain monotonically increasing time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stream_gap_time</strong> (<em>float</em>) &#8211; The time interval added between successive streams</li>
<li><strong>streams</strong> (<em>sequence of sequences containing (float, number) tuples</em>) &#8211; A sequence of streams</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  an edge stream representing the data from each stream in order</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.dropout">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">dropout</tt><big>(</big><em>samples</em>, <em>start_time</em>, <em>end_time</em>, <em>val=0.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.dropout" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a sample stream to a fixed level</p>
<p>This simulates the effect of a dropout in data transmission by
repacing samples with a fixed value.</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</li>
<li><strong>start_time</strong> (<em>float</em>) &#8211; Start of the dropout phase</li>
<li><strong>end_time</strong> (<em>float</em>) &#8211; End of the dropout phase</li>
<li><strong>val</strong> (<em>float</em>) &#8211; The sample value to substitute during the dropout phase</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.edges_to_sample_stream">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">edges_to_sample_stream</tt><big>(</big><em>edges</em>, <em>sample_period</em>, <em>end_extension=None</em>, <em>chunk_size=1000</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.edges_to_sample_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an edge stream to a sample stream</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edges</strong> (<em>iterable of (float, int) tuples</em>) &#8211; An edge stream to sample</li>
<li><strong>sample_period</strong> (<em>float</em>) &#8211; The sample period for converting the edge stream</li>
<li><strong>end_extension</strong> (<em>float</em>) &#8211; Optional amount of time to add to the end after the last edge transition</li>
<li><strong>chunk_size</strong> (<em>int</em>) &#8211; Number of samples in each SampleChunk</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a stream of SampleChunk objects.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.filter_waveform">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">filter_waveform</tt><big>(</big><em>samples</em>, <em>sample_rate</em>, <em>rise_time</em>, <em>ripple_db=60.0</em>, <em>chunk_size=1000</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.filter_waveform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a bandwidth limiting low-pass filter to a sample stream</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to be filtered.</li>
<li><strong>sample_rate</strong> (<em>float</em>) &#8211; The sample rate for converting the sample stream.</li>
<li><strong>rise_time</strong> (<em>float</em>) &#8211; Rise (and fall) time for the filtered samples.</li>
<li><strong>ripple_db</strong> (<em>float</em>) &#8211; Noise suppression in dB for the bandwidth filter stop band. This should
be a positive value.</li>
<li><strong>chunk_size</strong> (<em>int</em>) &#8211; Internal FIR filter sample pool size. This can generally be ignored. To support
streaming of samples, the FIR filter operation is done piecewise so we don&#8217;t have
to consume the entire input before producing filtered output. Larger values will
reduce the number of filter operations performed. Excessively small values will
waste time due to the reprocessing of overlapping samples between successive pools.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a stream of SampleChunk objects.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.invert">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">invert</tt><big>(</big><em>stream</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the polarity of stream values</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a sample stream.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.min_rise_time">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">min_rise_time</tt><big>(</big><em>sample_rate</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.min_rise_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the minimum rise time for a sample rate</p>
<p>This function is useful to determine the minimum rise time acceptable as parameters
to filter_waveform() and synth_wave(). You should use a scale factor to incease the rise
time at least slightly (e.g. rt * 1.01) to avoid raising a ValueError in those functions
due to floating point inaccuracies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sample_rate</strong> (<em>number</em>) &#8211; The sample rate to determine rise time from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A float for the minimum acceptable rise time.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.noisify">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">noisify</tt><big>(</big><em>samples</em>, <em>snr_db=30.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.noisify" title="Permalink to this definition">¶</a></dt>
<dd><p>Add noise to a sample stream</p>
<p>This modifies samples with additive, normally distributed noise</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</li>
<li><strong>snr_db</strong> (<em>float</em>) &#8211; The Signal to Noise Ratio in dB. This value is only accurate if the
input samples are normalized to the range 0.0 to 1.0. Any amplification
should be applied after noisify() for the SNR to be correct.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.quantize">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">quantize</tt><big>(</big><em>samples</em>, <em>full_scale</em>, <em>bits=8</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.quantize" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantize samples to simulate oscilloscope quantization error</p>
<p>This should be applied to a noisy signal to have notable results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; An iterable sample stream to modify.</li>
<li><strong>full_scale</strong> (<em>float</em>) &#8211; The full scale range for digitizer being emulated. For example,
a scope with 8 vertical divisions set at 2V/div. will have a
full scale range of 2V*8 = 16V</li>
<li><strong>bits</strong> (<em>int</em>) &#8211; The number of bits to quantize to</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.remove_excess_edges">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">remove_excess_edges</tt><big>(</big><em>edges</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.remove_excess_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove incorrect edge transitions from an edge stream</p>
<p>This is a generator function.</p>
<p>This function is most useful for conditioning the outputs of the protocol
synthesizers. For those protocols with multiple signals, the synthesizers
myst yield a new output set for <em>all</em> signals when any <em>one</em> of them changes.
This results in non-conforming edge streams that contain multiple consecutive
pairs with a non-changing value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>edges</strong> (<em>iterable of (float, int) tuples</em>) &#8211; An edge stream to filter for extraneous non-edges</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  an edge stream.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.sum_streams">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">sum_streams</tt><big>(</big><em>stream1</em>, <em>stream2</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.sum_streams" title="Permalink to this definition">¶</a></dt>
<dd><p>Add two sample streams together</p>
<p>The time elements of each stream will not be aligned if they do not match.
Instead the time values from stream1 are used for the result. The iterator
terminates when either of the two streams ends.</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stream1</strong> (<em>iterable of SampleChunk objects</em>) &#8211; </li>
<li><strong>stream2</strong> (<em>iterable of SampleChunk objects</em>) &#8211; The two sample streams to have their corresponding values added together.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.synth_wave">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">synth_wave</tt><big>(</big><em>edges</em>, <em>sample_rate</em>, <em>rise_time</em>, <em>ripple_db=60.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.synth_wave" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an edge stream to a sampled waveform with band limited rise/fall times</p>
<p>This is a convenience function combining edges_to_sample_stream() and
filter_waveform().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edges</strong> (<em>sequence of (float, int) tuples</em>) &#8211; An edge stream to be sampled</li>
<li><strong>sample_rate</strong> (<em>float</em>) &#8211; The sample rate for converting the edge stream</li>
<li><strong>rise_time</strong> (<em>float</em>) &#8211; Rise (and fall) time for the filtered samples</li>
<li><strong>ripple_db</strong> (<em>float</em>) &#8211; Noise suppression in dB for the bandwidth filter stop band. This should
be a positive value.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator for the synthesized sample stream</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.streaming">
<span id="streaming-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">streaming</span></tt> Module<a class="headerlink" href="#module-ripyl.streaming" title="Permalink to this headline">¶</a></h2>
<p>Data streaming common classes</p>
<dl class="class">
<dt id="ripyl.streaming.AnnotationFormat">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">AnnotationFormat</tt><a class="headerlink" href="#ripyl.streaming.AnnotationFormat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration of annotation data formats</p>
<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Bin">
<tt class="descname">Bin</tt><em class="property"> = 7</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Bin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Enum">
<tt class="descname">Enum</tt><em class="property"> = 8</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Enum" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.General">
<tt class="descname">General</tt><em class="property"> = 2</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Hex">
<tt class="descname">Hex</tt><em class="property"> = 6</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Hex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Hidden">
<tt class="descname">Hidden</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Hidden" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Int">
<tt class="descname">Int</tt><em class="property"> = 5</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Invisible">
<tt class="descname">Invisible</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Invisible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.String">
<tt class="descname">String</tt><em class="property"> = 3</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.String" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.AnnotationFormat.Text">
<tt class="descname">Text</tt><em class="property"> = 4</em><a class="headerlink" href="#ripyl.streaming.AnnotationFormat.Text" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="ripyl.streaming.AutoLevelError">
<em class="property">exception </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">AutoLevelError</tt><big>(</big><em>msg='Unable to find avg. logic levels of waveform'</em><big>)</big><a class="headerlink" href="#ripyl.streaming.AutoLevelError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.streaming.StreamError" title="ripyl.streaming.StreamError"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamError</span></tt></a></p>
<p>Custom exception class auto-level errors</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.ChunkExtractor">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">ChunkExtractor</tt><big>(</big><em>stream</em><big>)</big><a class="headerlink" href="#ripyl.streaming.ChunkExtractor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Utility class that pulls arbitrarily sized chunks from a sample stream</p>
<dl class="method">
<dt id="ripyl.streaming.ChunkExtractor.buffered_chunk">
<tt class="descname">buffered_chunk</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.streaming.ChunkExtractor.buffered_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all remaining buffered samples</p>
</dd></dl>

<dl class="method">
<dt id="ripyl.streaming.ChunkExtractor.next_chunk">
<tt class="descname">next_chunk</tt><big>(</big><em>chunk_size=1000</em><big>)</big><a class="headerlink" href="#ripyl.streaming.ChunkExtractor.next_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new chunk of samples from the stream</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>chunk_size</strong> (<em>int</em>) &#8211; The number of samples for this chunk.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A samplechunk object. if the stream had fewer than chunk_size samples
remaining then the SampleChunk.samples array is sized to hold only those samples.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None if the stream has ended.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.streaming.ChunkExtractor.next_samples">
<tt class="descname">next_samples</tt><big>(</big><em>sample_count=1000</em><big>)</big><a class="headerlink" href="#ripyl.streaming.ChunkExtractor.next_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a new set of raw samples from the stream</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sample_count</strong> (<em>int</em>) &#8211; The number of samples for the array.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A numpy array of float. if the stream had fewer than sample_count samples
remaining then the array is sized to hold only those samples.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None if the stream has ended.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.SampleChunk">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">SampleChunk</tt><big>(</big><em>samples</em>, <em>start_time</em>, <em>sample_period</em><big>)</big><a class="headerlink" href="#ripyl.streaming.SampleChunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>&#8216;Sample stream object</p>
<p>This represents a &#8220;chunk&#8221; of samples contained in a numpy array
stored in the samples attribute.</p>
</dd></dl>

<dl class="exception">
<dt id="ripyl.streaming.StreamError">
<em class="property">exception </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamError</tt><a class="headerlink" href="#ripyl.streaming.StreamError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.RuntimeError</span></tt></p>
<p>Custom exception class for edge and sample streams</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamEvent">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamEvent</tt><big>(</big><em>time</em>, <em>data=None</em>, <em>kind='unknown event'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></tt></a></p>
<p>A stream element that occurs at a specific point in time</p>
<dl class="method">
<dt id="ripyl.streaming.StreamEvent.summary">
<tt class="descname">summary</tt><big>(</big><em>a=None</em>, <em>depth=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamEvent.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield string(s) summarizing this segment and all of its subrecords
a (StreamRecord or None)</p>
<blockquote>
<div>StreamRecord to produce summary from. Uses self if None.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>depth</strong> (<em>int</em>) &#8211; Indentation level for this summary</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamRecord">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamRecord</tt><big>(</big><em>kind='unknown'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for protocol decoder output stream objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>kind</strong> &#8211; A string identifying the kind of record</li>
<li><strong>status</strong> &#8211; An integer status code</li>
<li><strong>stream_id</strong> &#8211; A unique numeric stream identifier</li>
<li><strong>subrecords</strong> &#8211; A list of child StreamRecord objects</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ripyl.streaming.StreamRecord.annotate">
<tt class="descname">annotate</tt><big>(</big><em>style=None</em>, <em>fields=None</em>, <em>data_format=2</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord.annotate" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;Set annotation attributes</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>style</strong> (<em>string or None</em>) &#8211; The name of a style to use for drawing a rectangle representing this record
(as defined in ripyl.util.plot.annotation_styles)</li>
<li><strong>fields</strong> (<em>dict of string:value</em>) &#8211; A set of arbitrary info fields that may be displayed as attributes of this record.
The special field &#8216;_bits&#8217; identifies the number of data bits in this record
The special field &#8216;_enum&#8217; identifies an enumeration type for this record&#8217;s data attribute
The special field &#8216;value&#8217; is a string that will override any other source of label text</li>
<li><strong>data_format</strong> (<em>AnnotationFormat</em>) &#8211; The format for the text label</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.streaming.StreamRecord.nested_status">
<tt class="descname">nested_status</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord.nested_status" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The highest status value from this record and its subrecords</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="ripyl.streaming.StreamRecord.status_text">
<em class="property">classmethod </em><tt class="descname">status_text</tt><big>(</big><em>status</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord.status_text" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The string representation of a status code</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.streaming.StreamRecord.text">
<tt class="descname">text</tt><big>(</big><em>default_format=3</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord.text" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a string representation of this segment&#8217;s data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>default_format</strong> (<em>AnnotationFormat</em>) &#8211; Set the format to use when the data_format attribute is General</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamSegment">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamSegment</tt><big>(</big><em>time_bounds</em>, <em>data=None</em>, <em>kind='unknown segment'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamSegment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></tt></a></p>
<p>A stream element that spans two points in time</p>
<dl class="attribute">
<dt id="ripyl.streaming.StreamSegment.end_time">
<tt class="descname">end_time</tt><a class="headerlink" href="#ripyl.streaming.StreamSegment.end_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamSegment.start_time">
<tt class="descname">start_time</tt><a class="headerlink" href="#ripyl.streaming.StreamSegment.start_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="ripyl.streaming.StreamSegment.summary">
<tt class="descname">summary</tt><big>(</big><em>a=None</em>, <em>depth=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamSegment.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield string(s) summarizing this segment and all of its subrecords
a (StreamRecord or None)</p>
<blockquote>
<div>StreamRecord to produce summary from. Uses self if None.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>depth</strong> (<em>int</em>) &#8211; Indentation level for this summary</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamStatus">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamStatus</tt><a class="headerlink" href="#ripyl.streaming.StreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for standard stream status codes</p>
<dl class="attribute">
<dt id="ripyl.streaming.StreamStatus.Error">
<tt class="descname">Error</tt><em class="property"> = 200</em><a class="headerlink" href="#ripyl.streaming.StreamStatus.Error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamStatus.Ok">
<tt class="descname">Ok</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.streaming.StreamStatus.Ok" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamStatus.Warning">
<tt class="descname">Warning</tt><em class="property"> = 100</em><a class="headerlink" href="#ripyl.streaming.StreamStatus.Warning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamType">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamType</tt><a class="headerlink" href="#ripyl.streaming.StreamType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for stream types</p>
<dl class="attribute">
<dt id="ripyl.streaming.StreamType.Edges">
<tt class="descname">Edges</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.streaming.StreamType.Edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamType.Samples">
<tt class="descname">Samples</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.streaming.StreamType.Samples" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.extract_all_samples">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">extract_all_samples</tt><big>(</big><em>samples</em><big>)</big><a class="headerlink" href="#ripyl.streaming.extract_all_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all samples from a sample stream along with parameter information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; The sample stream to extract samples from.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A tuple containing a numpy sample array of float, the start time,
and the sample period.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.extract_samples">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">extract_samples</tt><big>(</big><em>samples</em>, <em>sample_count=1000</em><big>)</big><a class="headerlink" href="#ripyl.streaming.extract_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new gerator that yields sample arrays of the desired size</p>
<p>This is a generator function. Its send() method can be used to change the
value of sample_count mid-stream.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; The sample stream to extract samples from.</li>
<li><strong>sample_count</strong> (<em>int</em>) &#8211; The number of samples for the arrays.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of numpy arrays. If the stream has fewer than sample_count samples
remaining then the array is sized to hold only those samples.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.load_stream">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">load_stream</tt><big>(</big><em>fh</em><big>)</big><a class="headerlink" href="#ripyl.streaming.load_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore a stream of StreamRecord objects from a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fh</strong> (<em>file-like object or a string</em>) &#8211; File to load records from. If a file handle is passed it should have been opened
in &#8216;rb&#8217; mode. If a string is passed it is the name of a file to read from.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of streamrecord objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.merge_streams">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">merge_streams</tt><big>(</big><em>records_a</em>, <em>records_b</em>, <em>id_a=0</em>, <em>id_b=1</em><big>)</big><a class="headerlink" href="#ripyl.streaming.merge_streams" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two streams of StreamRecord objects.
Records with time signatures from each input stream are kept in chronological order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>records_a</strong> (<em>StreamRecord</em>) &#8211; Source records from stream a</li>
<li><strong>records_b</strong> (<em>StreamRecord</em>) &#8211; Source records from stream b</li>
<li><strong>id_a</strong> (<em>int</em>) &#8211; stream_id assigned to records from records_a</li>
<li><strong>id_b</strong> (<em>int</em>) &#8211; stream_id assigned to records from records_b</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a stream of StreamRecord objects.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.rechunkify">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">rechunkify</tt><big>(</big><em>samples</em>, <em>chunk_size=1000</em><big>)</big><a class="headerlink" href="#ripyl.streaming.rechunkify" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new gerator that yields SampleChunk objects of the desired size</p>
<p>This is a generator function. Its send() method can be used to change the
value of chunk_size mid-stream.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; The sample stream to extract SampleChunk objects from.</li>
<li><strong>chunk_size</strong> (<em>int</em>) &#8211; The number of samples for the SampleChunk objects.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of SampleChunk objects. If the stream has fewer than chunk_size samples
remaining then the SampleChunk.samples array is sized to hold only those samples.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.sample_stream_to_samples">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">sample_stream_to_samples</tt><big>(</big><em>samples</em><big>)</big><a class="headerlink" href="#ripyl.streaming.sample_stream_to_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all samples from a sample stream as an array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>samples</strong> (<em>iterable of SampleChunk objects</em>) &#8211; The sample stream to extract samples from.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A numpy array of float.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.samples_to_sample_stream">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">samples_to_sample_stream</tt><big>(</big><em>raw_samples</em>, <em>sample_period</em>, <em>start_time=0.0</em>, <em>chunk_size=1000</em><big>)</big><a class="headerlink" href="#ripyl.streaming.samples_to_sample_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert raw samples to a chunked sample stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>raw_samples</strong> (<em>iterable of numbers</em>) &#8211; The samples to convert to a sample stream.</li>
<li><strong>sample_period</strong> (<em>float</em>) &#8211; The time interval between samples</li>
<li><strong>start_time</strong> (<em>float</em>) &#8211; The time for the first sample</li>
<li><strong>chunk_size</strong> (<em>int</em>) &#8211; The maximum number of samples for each chunk</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of SampleChunk objects representing the time and
sample value for each input sample. This can be fed to functions
that expect a chunked sample stream as input.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.save_stream">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">save_stream</tt><big>(</big><em>records</em>, <em>fh</em><big>)</big><a class="headerlink" href="#ripyl.streaming.save_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a stream of StreamRecord objects to a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>records</strong> (<em>StreamRecord sequence</em>) &#8211; The StreamRecord objects to save.</li>
<li><strong>fh</strong> (<em>file-like object or a string</em>) &#8211; File to save records to. If a file handle is passed it should have been
opened in &#8216;wb&#8217; mode. If a string is passed it is the name of a file to write to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">TypeError when records parameter is not a sequence.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.wave_synth">
<span id="wave-synth-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">wave_synth</span></tt> Module<a class="headerlink" href="#module-ripyl.wave_synth" title="Permalink to this headline">¶</a></h2>
<p>General routines for synthesizing basic waveforms</p>
<dl class="function">
<dt id="ripyl.wave_synth.sine_synth">
<tt class="descclassname">ripyl.wave_synth.</tt><tt class="descname">sine_synth</tt><big>(</big><em>frequency=1000000.0</em>, <em>phase=0.0</em>, <em>sample_period=5e-08</em>, <em>samples=None</em><big>)</big><a class="headerlink" href="#ripyl.wave_synth.sine_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Sine generator</p>
<p>Will generate a continuous stream of samples from a sine wave.
This generator will terminate if the number of output samples is specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frequency</strong> (<em>float</em>) &#8211; Frequency in Hz of the sine wave</li>
<li><strong>phase</strong> (<em>float</em>) &#8211; Phase in radians of the sine wave</li>
<li><strong>sample_period</strong> (<em>float</em>) &#8211; Time interval between samples</li>
<li><strong>samples</strong> (<em>int</em>) &#8211; Optional number of samples to generate</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of raw samples.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.wave_synth.square_synth">
<tt class="descclassname">ripyl.wave_synth.</tt><tt class="descname">square_synth</tt><big>(</big><em>frequency=1000000.0</em>, <em>duty=0.5</em>, <em>phase=0.0</em>, <em>sample_period=5e-08</em>, <em>samples=None</em><big>)</big><a class="headerlink" href="#ripyl.wave_synth.square_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Square wave generator</p>
<p>Will generate a continuous stream of samples from a square wave.
This generator will terminate if the number of output samples is specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frequency</strong> (<em>float</em>) &#8211; Frequency in Hz of the square wave</li>
<li><strong>duty</strong> (<em>float</em>) &#8211; Duty cycle of the square wave. Should be between 0.0 and 1.0.</li>
<li><strong>phase</strong> (<em>float</em>) &#8211; Phase of the square wave in fractions of a period. Should be between 0.0 and 1.0.</li>
<li><strong>sample_period</strong> (<em>float</em>) &#8211; Time interval between samples</li>
<li><strong>samples</strong> (<em>int</em>) &#8211; Optional number of samples to generate</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of raw samples.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="ripyl.cython.html">cython Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ripyl.cython.html#id1"><tt class="docutils literal"><span class="pre">cython</span></tt> Package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ripyl.protocol.html">protocol Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#id1"><tt class="docutils literal"><span class="pre">protocol</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.i2c"><tt class="docutils literal"><span class="pre">i2c</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.iso_k_line"><tt class="docutils literal"><span class="pre">iso_k_line</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.lm73"><tt class="docutils literal"><span class="pre">lm73</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.obd2"><tt class="docutils literal"><span class="pre">obd2</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.ps2"><tt class="docutils literal"><span class="pre">ps2</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.sagem_ecu"><tt class="docutils literal"><span class="pre">sagem_ecu</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.spi"><tt class="docutils literal"><span class="pre">spi</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.uart"><tt class="docutils literal"><span class="pre">uart</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.usb"><tt class="docutils literal"><span class="pre">usb</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.usb_transact"><tt class="docutils literal"><span class="pre">usb_transact</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#subpackages">Subpackages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="ripyl.protocol.infrared.html">infrared Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#id1"><tt class="docutils literal"><span class="pre">infrared</span></tt> Package</a></li>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.ir_common"><tt class="docutils literal"><span class="pre">ir_common</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.nec"><tt class="docutils literal"><span class="pre">nec</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.rc5"><tt class="docutils literal"><span class="pre">rc5</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.rc6"><tt class="docutils literal"><span class="pre">rc6</span></tt> Module</a></li>
<li class="toctree-l4"><a class="reference internal" href="ripyl.protocol.infrared.html#module-ripyl.protocol.infrared.sirc"><tt class="docutils literal"><span class="pre">sirc</span></tt> Module</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ripyl.util.html">util Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#id1"><tt class="docutils literal"><span class="pre">util</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.bitops"><tt class="docutils literal"><span class="pre">bitops</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.eng"><tt class="docutils literal"><span class="pre">eng</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.enum"><tt class="docutils literal"><span class="pre">enum</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.plot"><tt class="docutils literal"><span class="pre">plot</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.stats"><tt class="docutils literal"><span class="pre">stats</span></tt> Module</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/Ripyl logo 100px.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ripyl Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">ripyl</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-ripyl.config"><tt class="docutils literal"><span class="pre">config</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.decode"><tt class="docutils literal"><span class="pre">decode</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.sigproc"><tt class="docutils literal"><span class="pre">sigproc</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.streaming"><tt class="docutils literal"><span class="pre">streaming</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.wave_synth"><tt class="docutils literal"><span class="pre">wave_synth</span></tt> Module</a></li>
<li><a class="reference internal" href="#subpackages">Subpackages</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modules.html"
                        title="previous chapter">ripyl</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ripyl.cython.html"
                        title="next chapter">cython Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/apidoc/ripyl.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ripyl.cython.html" title="cython Package"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="ripyl"
             >previous</a> |</li>
        <li><a href="../index.html">Ripyl 1.1 documentation</a> &raquo;</li>
          <li><a href="modules.html" >ripyl</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Kevin Thibedeau.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>