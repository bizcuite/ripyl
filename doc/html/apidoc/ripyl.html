
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ripyl Package &mdash; Ripyl 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/ripyl.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Ripyl 1.0 documentation" href="../index.html" />
    <link rel="up" title="ripyl" href="modules.html" />
    <link rel="next" title="protocol Package" href="ripyl.protocol.html" />
    <link rel="prev" title="ripyl" href="modules.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ripyl.protocol.html" title="protocol Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="ripyl"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Ripyl 1.0 documentation</a> &raquo;</li>
          <li><a href="modules.html" accesskey="U">ripyl</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ripyl-package">
<h1>ripyl Package<a class="headerlink" href="#ripyl-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">ripyl</span></tt> Package<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-ripyl.__init__"></span><p>Ripyl protocol decode library</p>
</div>
<div class="section" id="module-ripyl.decode">
<span id="decode-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">decode</span></tt> Module<a class="headerlink" href="#module-ripyl.decode" title="Permalink to this headline">¶</a></h2>
<p>General routines shared between decoders</p>
<dl class="class">
<dt id="ripyl.decode.EdgeSequence">
<em class="property">class </em><tt class="descclassname">ripyl.decode.</tt><tt class="descname">EdgeSequence</tt><big>(</big><em>edges</em>, <em>time_step</em>, <em>start_time=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Utility class to walk through an edge iterator in arbitrary time steps</p>
<dl class="method">
<dt id="ripyl.decode.EdgeSequence.advance">
<tt class="descname">advance</tt><big>(</big><em>time_step=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Move forward through edges by a given amount of time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time_step</strong> (<em>float</em>) &#8211; The amount of time to move forward. If None, the default
time_step from the constructor is used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.EdgeSequence.advance_to_edge">
<tt class="descname">advance_to_edge</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.advance_to_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance to the next edge in the iterator after the current time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The amount of time advanced as a float.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.EdgeSequence.at_end">
<tt class="descname">at_end</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.at_end" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True when the edge iterator has terminated</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.EdgeSequence.cur_state">
<tt class="descname">cur_state</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.EdgeSequence.cur_state" title="Permalink to this definition">¶</a></dt>
<dd><p>The logic level of the edge iterator at the current time</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.decode.MultiEdgeSequence">
<em class="property">class </em><tt class="descclassname">ripyl.decode.</tt><tt class="descname">MultiEdgeSequence</tt><big>(</big><em>edge_sets</em>, <em>time_step</em>, <em>start_time=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Utility class to walk through a group of edge iterators in arbitrary time steps</p>
<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.advance">
<tt class="descname">advance</tt><big>(</big><em>time_step=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.advance" title="Permalink to this definition">¶</a></dt>
<dd><p>Move forward through edges by a given amount of time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>time_step</strong> (<em>float</em>) &#8211; The amount of time to move forward. If None, the default
time_step from the constructor is used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.advance_to_edge">
<tt class="descname">advance_to_edge</tt><big>(</big><em>channel_name=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.advance_to_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Advance to the next edge among the edge sets or in a named channel
after the current time</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>channel_name</strong> (<em>string</em>) &#8211; If None, the edge sets are advanced to the closest edge after the current
time. if a valid channel name is provided the edge sets are advanced to
the closest edge on that channel.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A tuple (time, channel_name) representing the amount of time advanced
as a float and the name of the channel containing the edge. If there are no
unterminated edge sequences then the tuple (0,0, &#8216;&#8217;) is returned.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body">ValueError if channel_name is invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.at_end">
<tt class="descname">at_end</tt><big>(</big><em>channel_name=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.at_end" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the sequences have ended</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>channel_name</strong> (<em>string</em>) &#8211; The name of the channel to test for termination</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True when the named edge iterator has terminated. if channel_name is
None, returns True when all channels in the set have terminated.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body">ValueError if channel_name is invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.cur_state">
<tt class="descname">cur_state</tt><big>(</big><em>channel_name=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.cur_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current state of the edge sets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>channel_name</strong> (<em>string</em>) &#8211; Name of the channel to retrieve state from</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The value of the named channel&#8217;s state. if channel_name is none
the state of all channels is returned as a list.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body">ValueError if channel_name is invalid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="ripyl.decode.MultiEdgeSequence.cur_time">
<tt class="descname">cur_time</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.decode.MultiEdgeSequence.cur_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current time of the edge sets</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_bot_top_hist_peaks">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_bot_top_hist_peaks</tt><big>(</big><em>raw_samples</em>, <em>bins</em>, <em>use_kde=False</em>, <em>kde_bw=0.05</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_bot_top_hist_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the bottom and top peaks in a histogram of data sample magnitudes.
These are the left-most and right-most of the two largest peaks in the histogram.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>raw_samples</strong> (<em>sequence of numbers</em>) &#8211; A sequence representing the population of data samples that will be
analyzed for peaks</li>
<li><strong>bins</strong> (<em>int</em>) &#8211; The number of bins to use for the histogram</li>
<li><strong>use_kde</strong> (<em>bool</em>) &#8211; Boolean indicating whether to construct the histogram from a Kernel Density
Estimate. This is useful for approximating normally distributed peaks on
synthetic data sets lacking noise.</li>
<li><strong>kde_bw</strong> (<em>float</em>) &#8211; Float providing the bandwidth parameter for the KDE</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A 2-tuple (bot, top) representing the bottom and top peaks. the value for
each peak is the center of the histogram bin that represents the midpoint of the
population for that peak.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">None if less than two peaks are found in the histogram</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">ValueError if a KDE cannot be constructed</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_differential_edges">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_differential_edges</tt><big>(</big><em>samples</em>, <em>logic</em>, <em>hysteresis=0.1</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_differential_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the edges in a sampled differential digital waveform</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<p>The samples should be from a differential input such that the input signal can
be in one of three states: differential +1, differential -1, or 0.</p>
<p>Note that the output of this function cannot be used directly without further
processing. Transitions from -1 to +1 and vice versa cannot be easily
distinguished from transitions from -/+1 to 0 to +/-1. Short periods in the 0 state
should be removed but this requires knowledge of the minimum time for a 0 state
to be valid. This is performed by the remove_short_diff_0s() function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>sequence of (float, number) tuples</em>) &#8211; An iterable representing a sequence of samples. Each sample is a
2-tuple representing the time of the sample and the sample&#8217;s value.</li>
<li><strong>logic</strong> (<em>(float, float)</em>) &#8211; A 2-tuple (low, high) representing the mean logic levels in the sampled waveform
for -1 and +1. The logic level for 0 is assumed to be midway between these two.</li>
<li><strong>hysteresis</strong> (<em>float</em>) &#8211; A value between 0.0 and 1.0 representing the amount of hysteresis the use for
detecting valid edge crossings.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of 2-tuples (time, value) representing the time and
logic value (-1, 0, or 1) for each edge transition. The first tuple
yielded is the initial state of the sampled waveform. All remaining
tuples are detected edges.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if the stream is empty</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_edges">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_edges</tt><big>(</big><em>samples</em>, <em>logic</em>, <em>hysteresis=0.4</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the edges in a sampled digital waveform</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>sequence of (float, number) tuples</em>) &#8211; An iterable representing a sequence of samples. Each sample is a
2-tuple representing the time of the sample and the sample&#8217;s value.</li>
<li><strong>logic</strong> (<em>(float, float)</em>) &#8211; A 2-tuple (low, high) representing the mean logic levels in the sampled waveform</li>
<li><strong>hysteresis</strong> (<em>float</em>) &#8211; A value between 0.0 and 1.0 representing the amount of hysteresis the use for
detecting valid edge crossings.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of 2-tuples (time, value) representing the time and
logic value (0 or 1) for each edge transition. The first tuple
yielded is the initial state of the sampled waveform. All remaining
tuples are detected edges.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if the stream is empty</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_hist_peaks">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_hist_peaks</tt><big>(</big><em>hist</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_hist_peaks" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all peaks in a histogram
This uses a modification of the method employed by the &#8220;peaks&#8221; function in
LeCroy digital oscilloscopes. The original algorithm is described in various manuals
such as the 9300 WP03 manual or WavePro manual RevC 2002 (p16-14).</p>
<p>This algorithm works well for real world data sets where the histogram peaks are
normally distributed (i.e. there is some noise present in the data set).
For synthetic waveforms lacking noise or any intermediate samples between discrete
logic levels, the statistical measures used to determine the threshold for a peak
are not valid. The threshold t2 ends up being too large and valid peaks may be
excluded. To avoid this problem the histogram can be sampled from a KDE instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hist</strong> (<em>sequence of ints</em>) &#8211; A sequence representing the histogram bin counts. Typically the first parameter
returned by numpy.histogram() or a KDE from scipy.stats.gaussian_kde().</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of peaks where each peak is a 2-tuple representing the
start and end indices of the peak in hist.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_logic_levels">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_logic_levels</tt><big>(</big><em>samples</em>, <em>max_samples=20000</em>, <em>buf_size=2000</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_logic_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Automatically determine the logic levels of a digital signal.</p>
<p>This function consumes up to max_samples from samples in an attempt
to build a buffer containing a representative set of samples at high
and low logic levels. Less than max_samples may be consumed if an edge
is found and the remaining half of the buffer is filled before the
max_samples threshold is reached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>sequence of (float, number) tuples</em>) &#8211; An iterable representing a sequence of samples. Each sample is a
2-tuple representing the time of the sample and the sample&#8217;s value.</li>
<li><strong>max_samples</strong> (<em>int</em>) &#8211; The maximum number of samples to consume from the samples iterable.
This should be at least 2x buf_size and will be coerced to that value
if it is less.</li>
<li><strong>buf_size</strong> (<em>int</em>) &#8211; The maximum size of the sample buffer to analyze for logic levels.
This should be less than max_samples.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A 2-tuple (low, high) representing the logic levels of the samples</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None if less than two peaks are found in the sample histogram.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.find_symbol_rate">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">find_symbol_rate</tt><big>(</big><em>edges</em>, <em>sample_rate=1.0</em>, <em>spectra=2</em>, <em>auto_span_limit=True</em>, <em>max_span_limit=None</em><big>)</big><a class="headerlink" href="#ripyl.decode.find_symbol_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the base symbol rate from a set of edges</p>
<p>This function depends on the edge data containing a variety of spans between
edges all related to the fundamental symbol rate. The Harmonic Product Spectrum
(HPS) of the edge span values is calculated and used to isolate the fundamental
symbol rate. This function will not work properly on a clock signal containing
a single time span between edges due to the lack of higher fundementals needed
by the HPS unless spectra=1 which effectively disables the HPS operation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edges</strong> (<em>[(float, int)...] or [(int, int)...]</em>) &#8211; <p>An iterable of 2-tuples representing each edge transition.
The tuples are in one of two forms:</p>
<blockquote>
<div><ul>
<li>absolute time  (time, logic level)</li>
<li>sample indexed (index, logic level)</li>
</ul>
</div></blockquote>
<p>This function will consume all elements of the edges iterable.
It must have a finite length</p>
</li>
<li><strong>sample_rate</strong> (<em>float</em>) &#8211; An adjustment to convert the raw symbol rate from samples to time.
If the edges parameter is based on absolute time units then this
should remain the default value of 1.0.</li>
<li><strong>spectra</strong> (<em>int</em>) &#8211; The number of spectra to include in the calculation of the HPS. This
number should not larger than the highest harmonic in the edge span
data.</li>
<li><strong>auto_span_limit</strong> (<em>bool</em>) &#8211; Excessively long edge spans can impair the symbol rate detection by
reducing the resolution of the HPS. They are typically the result of
long idle periods between the interesting parts we want to estimate
the symbol rate from. When this parameter is True, an attempt is made
to find the ideal limit for the spans included in the HPS.</li>
<li><strong>max_span_limit</strong> (<em>int</em>) &#8211; An optional upper limit for span length to include in the HPS.
auto_span_limit must be False for this to take effect.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The estimated symbol rate of the edge data set as an int</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">ValueError if there are not enough edge spans to evaluate
a HPS.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.gen_histogram">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">gen_histogram</tt><big>(</big><em>raw_samples</em>, <em>bins</em>, <em>use_kde=False</em>, <em>kde_bw=0.05</em><big>)</big><a class="headerlink" href="#ripyl.decode.gen_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a histogram using either normal binning or a KDE</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>raw_samples</strong> (<em>sequence of numbers</em>) &#8211; A sequence representing the population of data samples that will be
analyzed for peaks</li>
<li><strong>bins</strong> (<em>int</em>) &#8211; The number of bins to use for the histogram</li>
<li><strong>use_kde</strong> (<em>bool</em>) &#8211; Boolean indicating whether to construct the histogram from a Kernel Density
Estimate. This is useful for approximating normally distributed peaks on
synthetic data sets lacking noise.</li>
<li><strong>kde_bw</strong> (<em>float</em>) &#8211; Float providing the bandwidth parameter for the KDE</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple (hist, bin_centers) containing lists of the histogram bins and
the center value of each bin.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.decode.remove_short_diff_0s">
<tt class="descclassname">ripyl.decode.</tt><tt class="descname">remove_short_diff_0s</tt><big>(</big><em>diff_edges</em>, <em>min_diff_0_time</em><big>)</big><a class="headerlink" href="#ripyl.decode.remove_short_diff_0s" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter out unwanted differential 0&#8217;s from an edge stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>diff_edges</strong> (<em>sequence of (float, int) tuples</em>) &#8211; An iterable of 2-tuples representing each edge transition.
The 2-tuples <em>must</em> be in the absolute time form (time, logic level).
The logic levels should be in the set (-1, 0, 1) as produced by
find_differential_edges().</li>
<li><strong>min_diff_0_time</strong> (<em>float</em>) &#8211; The threshold for differential 0 states. A diff 0 lasting less than this
threshold will be filtered out of the edge stream.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">An iterator yielding  a series of 2-tuples (time, value) representing the time and
logic value (-1, 0, or 1) for each edge transition. The first tuple
yielded is the initial state of the sampled waveform. All remaining
tuples are detected edges.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">StreamError if the stream is empty</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.sigproc">
<span id="sigproc-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">sigproc</span></tt> Module<a class="headerlink" href="#module-ripyl.sigproc" title="Permalink to this headline">¶</a></h2>
<p>General routines for signal processing of streaming waveforms</p>
<dl class="function">
<dt id="ripyl.sigproc.amplify">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">amplify</tt><big>(</big><em>samples</em>, <em>gain=1.0</em>, <em>offset=0.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.amplify" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply gain and offset to a sample stream</p>
<p>This modifies samples such that output = input * gain + offset.</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>sequence of (float, number) tuples</em>) &#8211; An iterable sample stream of (time, value) pairs.</li>
<li><strong>gain</strong> (<em>float</em>) &#8211; The gain multiplier for the samples</li>
<li><strong>offset</strong> (<em>float</em>) &#8211; The additive offset for the samples</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.chain">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">chain</tt><big>(</big><em>stream_gap_time</em>, <em>*streams</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine a sequence of streams together.</p>
<p>A set of sample or edge streams are concatenated together with updated time
stamps to maintain monotonically increasing time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stream_gap_time</strong> (<em>float</em>) &#8211; The time interval added between successive streams</li>
<li><strong>streams</strong> (<em>sequence of sequences containing (float, number) tuples</em>) &#8211; A sequence of streams</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a stream representing the data from each stream in order</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.dropout">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">dropout</tt><big>(</big><em>samples</em>, <em>start_time</em>, <em>end_time</em>, <em>val=0.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.dropout" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a sample stream to a fixed level</p>
<p>This simulates the effect of a dropout in data transmission by
repacing samples with a fixed value.</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>sequence of (float, number) tuples</em>) &#8211; An iterable sample stream of (time, value) pairs.</li>
<li><strong>start_time</strong> (<em>float</em>) &#8211; Start of the dropout phase</li>
<li><strong>end_time</strong> (<em>float</em>) &#8211; End of the dropout phase</li>
<li><strong>val</strong> (<em>float</em>) &#8211; The sample value to substitute during the dropout phase</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.edges_to_sample_stream">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">edges_to_sample_stream</tt><big>(</big><em>edges</em>, <em>sample_period</em>, <em>end_extension=None</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.edges_to_sample_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an edge stream to a sample stream</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edges</strong> (<em>sequence of (float, int) tuples</em>) &#8211; An edge stream to sample</li>
<li><strong>sample_rate</strong> (<em>float</em>) &#8211; The sample rate for converting the edge stream</li>
<li><strong>end_extension</strong> (<em>float</em>) &#8211; Optional amount of time to add to the end after the last edge transition</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.filter_waveform">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">filter_waveform</tt><big>(</big><em>samples</em>, <em>sample_rate</em>, <em>rise_time</em>, <em>ripple_db=60.0</em>, <em>pool_size=1000</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.filter_waveform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a bandwidth limiting low-pass filter to a sample stream</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>sequence of (float, number) tuples</em>) &#8211; A sample stream to be filtered.</li>
<li><strong>sample_rate</strong> (<em>float</em>) &#8211; The sample rate for converting the sample stream.</li>
<li><strong>rise_time</strong> (<em>float</em>) &#8211; Rise (and fall) time for the filtered samples.</li>
<li><strong>ripple_db</strong> (<em>float</em>) &#8211; Noise suppression in dB for the bandwidth filter stop band. This should
be a positive value.</li>
<li><strong>pool_size</strong> (<em>int</em>) &#8211; Internal FIR filter sample pool size. This can generally be ignored. To support
streaming of samples, the FIR filter operation is done piecewise so we don&#8217;t have
to consume the entire input before producing filtered output. Larger values will
reduce the number of filter operations performed. Excessively small values will
waste time due to the reprocessing of overlapping samples between successive pools.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.invert">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">invert</tt><big>(</big><em>stream</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Invert the polarity of stream values</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stream</strong> (<em>sequence of (float, number) tuples</em>) &#8211; An iterable of stream (time, value) pairs. The stream can either be samples
or a diferential edge stream containing (-1, 0, 1) values that must be
inverted.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  a stream of inverted elements</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.noisify">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">noisify</tt><big>(</big><em>samples</em>, <em>snr_db=30.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.noisify" title="Permalink to this definition">¶</a></dt>
<dd><p>Add noise to a sample stream</p>
<p>This modifies samples with additive, normally distributed noise</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>sequence of (float, number) tuples</em>) &#8211; An iterable sample stream of (time, value) pairs.</li>
<li><strong>snr_db</strong> (<em>float</em>) &#8211; The Signal to Noise Ratio in dB. This value is only accurate if the
input samples are normalized to the range 0.0 to 1.0. Any amplification
should be applied after noisify() for the SNR to be correct.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.quantize">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">quantize</tt><big>(</big><em>samples</em>, <em>full_scale</em>, <em>bits=8</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.quantize" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantize samples to simulate oscilloscope quantization error</p>
<p>This should be applied to a noisy signal to have notable results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>samples</strong> (<em>sequence of (float, number) tuples</em>) &#8211; An iterable sample stream of (time, value) pairs.</li>
<li><strong>full_scale</strong> (<em>float</em>) &#8211; The full scale range for the signal.</li>
<li><strong>bits</strong> (<em>int</em>) &#8211; The number of bits to quantize to</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.remove_excess_edges">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">remove_excess_edges</tt><big>(</big><em>edges</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.remove_excess_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove incorrect edge transitions from an edge stream</p>
<p>This is a generator function.</p>
<p>This function is most useful for conditioning the outputs of the protocol
synthesizers. For those protocols with multiple signals, the synthesizers
myst yield a new output set for <em>all</em> signals when any <em>one</em> of them changes.
This results in non-conforming edge streams that contain multiple consecutive
pairs with a non-changing value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>edges</strong> (<em>sequence of (float, int) tuples</em>) &#8211; An edge stream to filter for extraneous non-edges</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An iterator yielding  an edge stream.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.samples_to_sample_stream">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">samples_to_sample_stream</tt><big>(</big><em>raw_samples</em>, <em>sample_period</em>, <em>start_time=0.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.samples_to_sample_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert raw samples to a sample stream</p>
<p>This is a generator function that can be used in a pipeline of waveform
procesing operations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>raw_samples</strong> (<em>sequence of numbers</em>) &#8211; An iterable of sample values</li>
<li><strong>sample_period</strong> (<em>float</em>) &#8211; The time interval between samples</li>
<li><strong>start_time</strong> (<em>float</em>) &#8211; The time for the first sample</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of 2-tuples (time, value) representing the time and
sample value for each input sample. This can be fed to functions
that expect a sample stream as input.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.sum_streams">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">sum_streams</tt><big>(</big><em>stream1</em>, <em>stream2</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.sum_streams" title="Permalink to this definition">¶</a></dt>
<dd><p>Add two sample streams together</p>
<p>The time elements of each stream will not be aligned if they do not match.
Instead the time values from stream1 are used for the result. The iterator
terminates when either of the two streams ends.</p>
<p>This is a generator function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>stream1</strong> (<em>sequence of (float, number) tuples</em>) &#8211; </li>
<li><strong>stream2</strong> (<em>sequence of (float, number) tuples</em>) &#8211; The two sample streams to have their corresponding values added together.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a sample stream.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.sigproc.synth_wave">
<tt class="descclassname">ripyl.sigproc.</tt><tt class="descname">synth_wave</tt><big>(</big><em>edges</em>, <em>sample_rate</em>, <em>rise_time</em>, <em>ripple_db=60.0</em><big>)</big><a class="headerlink" href="#ripyl.sigproc.synth_wave" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an edge stream to a sampled waveform with band limited rise/fall times</p>
<p>This is a convenience function combining edges_to_sample_stream() and
filter_waveform().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>edges</strong> (<em>sequence of (float, int) tuples</em>) &#8211; An edge stream to be sampled</li>
<li><strong>sample_rate</strong> (<em>float</em>) &#8211; The sample rate for converting the edge stream</li>
<li><strong>rise_time</strong> (<em>float</em>) &#8211; Rise (and fall) time for the filtered samples</li>
<li><strong>ripple_db</strong> (<em>float</em>) &#8211; Noise suppression in dB for the bandwidth filter stop band. This should
be a positive value.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator for the synthesized sample stream</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.streaming">
<span id="streaming-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">streaming</span></tt> Module<a class="headerlink" href="#module-ripyl.streaming" title="Permalink to this headline">¶</a></h2>
<p>Data streaming common classes</p>
<dl class="exception">
<dt id="ripyl.streaming.AutoLevelError">
<em class="property">exception </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">AutoLevelError</tt><big>(</big><em>msg='Unable to find avg. logic levels of waveform'</em><big>)</big><a class="headerlink" href="#ripyl.streaming.AutoLevelError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.streaming.StreamError" title="ripyl.streaming.StreamError"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamError</span></tt></a></p>
<p>Custom exception class auto-level errors</p>
</dd></dl>

<dl class="exception">
<dt id="ripyl.streaming.StreamError">
<em class="property">exception </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamError</tt><a class="headerlink" href="#ripyl.streaming.StreamError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.RuntimeError</span></tt></p>
<p>Custom exception class for edge and sample streams</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamEvent">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamEvent</tt><big>(</big><em>time</em>, <em>data=None</em>, <em>kind='unknown event'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></tt></a></p>
<p>A stream element that occurs at a specific point in time</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamRecord">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamRecord</tt><big>(</big><em>kind='unknown'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for protocol decoder output stream objects</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>kind</strong> &#8211; A string identifying the kind of record</li>
<li><strong>status</strong> &#8211; An integer status code</li>
<li><strong>stream_id</strong> &#8211; A unique numeric stream identifier</li>
<li><strong>subrecords</strong> &#8211; A list of child StreamRecord objects</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="ripyl.streaming.StreamRecord.nested_status">
<tt class="descname">nested_status</tt><big>(</big><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord.nested_status" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The highest status value from this record and its subrecords</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="ripyl.streaming.StreamRecord.status_text">
<em class="property">classmethod </em><tt class="descname">status_text</tt><big>(</big><em>status</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamRecord.status_text" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The string representation of a status code</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamSegment">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamSegment</tt><big>(</big><em>time_bounds</em>, <em>data=None</em>, <em>kind='unknown segment'</em>, <em>status=0</em><big>)</big><a class="headerlink" href="#ripyl.streaming.StreamSegment" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#ripyl.streaming.StreamRecord" title="ripyl.streaming.StreamRecord"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.streaming.StreamRecord</span></tt></a></p>
<p>A stream element that spans two points in time</p>
</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamStatus">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamStatus</tt><a class="headerlink" href="#ripyl.streaming.StreamStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for standard stream status codes</p>
<dl class="attribute">
<dt id="ripyl.streaming.StreamStatus.Error">
<tt class="descname">Error</tt><em class="property"> = 200</em><a class="headerlink" href="#ripyl.streaming.StreamStatus.Error" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamStatus.Ok">
<tt class="descname">Ok</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.streaming.StreamStatus.Ok" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamStatus.Warning">
<tt class="descname">Warning</tt><em class="property"> = 100</em><a class="headerlink" href="#ripyl.streaming.StreamStatus.Warning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="ripyl.streaming.StreamType">
<em class="property">class </em><tt class="descclassname">ripyl.streaming.</tt><tt class="descname">StreamType</tt><a class="headerlink" href="#ripyl.streaming.StreamType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="ripyl.util.html#ripyl.util.enum.Enum" title="ripyl.util.enum.Enum"><tt class="xref py py-class docutils literal"><span class="pre">ripyl.util.enum.Enum</span></tt></a></p>
<p>Enumeration for stream types</p>
<dl class="attribute">
<dt id="ripyl.streaming.StreamType.Edges">
<tt class="descname">Edges</tt><em class="property"> = 0</em><a class="headerlink" href="#ripyl.streaming.StreamType.Edges" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="ripyl.streaming.StreamType.Samples">
<tt class="descname">Samples</tt><em class="property"> = 1</em><a class="headerlink" href="#ripyl.streaming.StreamType.Samples" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.load_stream">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">load_stream</tt><big>(</big><em>fh</em><big>)</big><a class="headerlink" href="#ripyl.streaming.load_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore a stream of StreamRecord objects from a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fh</strong> (<em>file-like object or a string</em>) &#8211; File to load records from. If a file handle is passed it should have been opened
in &#8216;rb&#8217; mode. If a string is passed it is the name of a file to read from.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A list of streamrecord objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.merge_streams">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">merge_streams</tt><big>(</big><em>records_a</em>, <em>records_b</em>, <em>id_a=0</em>, <em>id_b=1</em><big>)</big><a class="headerlink" href="#ripyl.streaming.merge_streams" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine two streams of StreamRecord objects.
Records with time signatures from each input stream are kept in chronological order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>records_a</strong> (<em>StreamRecord</em>) &#8211; Source records from stream a</li>
<li><strong>records_b</strong> (<em>StreamRecord</em>) &#8211; Source records from stream b</li>
<li><strong>id_a</strong> (<em>int</em>) &#8211; stream_id assigned to records from records_a</li>
<li><strong>id_b</strong> (<em>int</em>) &#8211; stream_id assigned to records from records_b</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a stream of StreamRecord objects.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.streaming.save_stream">
<tt class="descclassname">ripyl.streaming.</tt><tt class="descname">save_stream</tt><big>(</big><em>records</em>, <em>fh</em><big>)</big><a class="headerlink" href="#ripyl.streaming.save_stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a stream of StreamRecord objects to a file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>records</strong> (<em>StreamRecord sequence</em>) &#8211; The StreamRecord objects to save.</li>
<li><strong>fh</strong> (<em>file-like object or a string</em>) &#8211; File to save records to. If a file handle is passed it should have been
opened in &#8216;wb&#8217; mode. If a string is passed it is the name of a file to write to.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises :</th><td class="field-body"><p class="first last">TypeError when records parameter is not a sequence.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ripyl.wave_synth">
<span id="wave-synth-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">wave_synth</span></tt> Module<a class="headerlink" href="#module-ripyl.wave_synth" title="Permalink to this headline">¶</a></h2>
<p>General routines for synthesizing basic waveforms</p>
<dl class="function">
<dt id="ripyl.wave_synth.sine_synth">
<tt class="descclassname">ripyl.wave_synth.</tt><tt class="descname">sine_synth</tt><big>(</big><em>frequency=1000000.0</em>, <em>phase=0.0</em>, <em>sample_period=5e-08</em>, <em>samples=None</em><big>)</big><a class="headerlink" href="#ripyl.wave_synth.sine_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Sine generator</p>
<p>Will generate a continuous stream of samples from a sine wave.
This generator will terminate if the number of output samples is specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frequency</strong> (<em>float</em>) &#8211; Frequency in Hz of the sine wave</li>
<li><strong>phase</strong> (<em>float</em>) &#8211; Phase in radians of the sine wave</li>
<li><strong>sample_period</strong> (<em>float</em>) &#8211; Time interval between samples</li>
<li><strong>samples</strong> (<em>int</em>) &#8211; Optional number of samples to generate</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of raw samples.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ripyl.wave_synth.square_synth">
<tt class="descclassname">ripyl.wave_synth.</tt><tt class="descname">square_synth</tt><big>(</big><em>frequency=1000000.0</em>, <em>duty=0.5</em>, <em>phase=0.0</em>, <em>sample_period=5e-08</em>, <em>samples=None</em><big>)</big><a class="headerlink" href="#ripyl.wave_synth.square_synth" title="Permalink to this definition">¶</a></dt>
<dd><p>Square wave generator</p>
<p>Will generate a continuous stream of samples from a square wave.
This generator will terminate if the number of output samples is specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>frequency</strong> (<em>float</em>) &#8211; Frequency in Hz of the square wave</li>
<li><strong>duty</strong> (<em>float</em>) &#8211; Duty cycle of the square wave. Should be between 0.0 and 1.0.</li>
<li><strong>phase</strong> (<em>float</em>) &#8211; Phase of the square wave in fractions of a period. Should be between 0.0 and 1.0.</li>
<li><strong>sample_period</strong> (<em>float</em>) &#8211; Time interval between samples</li>
<li><strong>samples</strong> (<em>int</em>) &#8211; Optional number of samples to generate</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator yielding  a series of raw samples.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="ripyl.protocol.html">protocol Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.i2c"><tt class="docutils literal"><span class="pre">i2c</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.iso_k_line"><tt class="docutils literal"><span class="pre">iso_k_line</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.lm73"><tt class="docutils literal"><span class="pre">lm73</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.obd2"><tt class="docutils literal"><span class="pre">obd2</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.ps2"><tt class="docutils literal"><span class="pre">ps2</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.sagem_ecu"><tt class="docutils literal"><span class="pre">sagem_ecu</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.spi"><tt class="docutils literal"><span class="pre">spi</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.uart"><tt class="docutils literal"><span class="pre">uart</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.usb"><tt class="docutils literal"><span class="pre">usb</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.protocol.html#module-ripyl.protocol.usb_transact"><tt class="docutils literal"><span class="pre">usb_transact</span></tt> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ripyl.util.html">util Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#id1"><tt class="docutils literal"><span class="pre">util</span></tt> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.bitops"><tt class="docutils literal"><span class="pre">bitops</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.eng"><tt class="docutils literal"><span class="pre">eng</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.enum"><tt class="docutils literal"><span class="pre">enum</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.plot"><tt class="docutils literal"><span class="pre">plot</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="ripyl.util.html#module-ripyl.util.stats"><tt class="docutils literal"><span class="pre">stats</span></tt> Module</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/Ripyl logo 100px.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">ripyl Package</a><ul>
<li><a class="reference internal" href="#id1"><tt class="docutils literal"><span class="pre">ripyl</span></tt> Package</a></li>
<li><a class="reference internal" href="#module-ripyl.decode"><tt class="docutils literal"><span class="pre">decode</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.sigproc"><tt class="docutils literal"><span class="pre">sigproc</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.streaming"><tt class="docutils literal"><span class="pre">streaming</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-ripyl.wave_synth"><tt class="docutils literal"><span class="pre">wave_synth</span></tt> Module</a></li>
<li><a class="reference internal" href="#subpackages">Subpackages</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modules.html"
                        title="previous chapter">ripyl</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ripyl.protocol.html"
                        title="next chapter">protocol Package</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/apidoc/ripyl.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="ripyl.protocol.html" title="protocol Package"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="ripyl"
             >previous</a> |</li>
        <li><a href="../index.html">Ripyl 1.0 documentation</a> &raquo;</li>
          <li><a href="modules.html" >ripyl</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Kevin Thibedeau.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>